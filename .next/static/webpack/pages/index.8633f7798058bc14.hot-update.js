"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./pages/utils.ts":
/*!************************!*\
  !*** ./pages/utils.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SQL_TEMPLATE: () => (/* binding */ SQL_TEMPLATE),\n/* harmony export */   TEMPLATES: () => (/* binding */ TEMPLATES),\n/* harmony export */   convertToGo: () => (/* binding */ convertToGo),\n/* harmony export */   formatJSON: () => (/* binding */ formatJSON),\n/* harmony export */   formatYAML: () => (/* binding */ formatYAML),\n/* harmony export */   jsonToGo: () => (/* binding */ jsonToGo),\n/* harmony export */   sqlToGoStruct: () => (/* binding */ sqlToGoStruct),\n/* harmony export */   validateFormat: () => (/* binding */ validateFormat)\n/* harmony export */ });\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ \"(pages-dir-browser)/./node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/index.js\");\n\nfunction inferGoType(value) {\n    let seen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set();\n    if (value === null || value === undefined) {\n        return {\n            type: \"interface{}\",\n            isPointer: true,\n            isArray: false\n        };\n    }\n    if (Array.isArray(value)) {\n        if (value.length === 0) {\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: true\n            };\n        }\n        // 分析数组中的所有元素类型\n        const elementTypes = value.map((item)=>inferGoType(item, seen));\n        // 如果所有元素类型相同，使用该类型；否则使用 interface{}\n        const isSameType = elementTypes.every((t)=>t.type === elementTypes[0].type && t.isPointer === elementTypes[0].isPointer);\n        return {\n            type: isSameType ? elementTypes[0].type : \"interface{}\",\n            isPointer: isSameType ? elementTypes[0].isPointer : false,\n            isArray: true,\n            elementType: isSameType ? elementTypes[0] : undefined\n        };\n    }\n    switch(typeof value){\n        case \"string\":\n            return {\n                type: \"string\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"number\":\n            if (Number.isInteger(value)) {\n                if (value > 2147483647 || value < -2147483648) {\n                    return {\n                        type: \"int64\",\n                        isPointer: false,\n                        isArray: false\n                    };\n                }\n                return {\n                    type: \"int\",\n                    isPointer: false,\n                    isArray: false\n                };\n            }\n            return {\n                type: \"float64\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"boolean\":\n            return {\n                type: \"bool\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"object\":\n            if (seen.has(value)) {\n                return {\n                    type: \"interface{}\",\n                    isPointer: true,\n                    isArray: false\n                };\n            }\n            seen.add(value);\n            return {\n                type: \"struct\",\n                isPointer: false,\n                isArray: false\n            };\n        default:\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: false\n            };\n    }\n}\nfunction formatGoFieldType(type) {\n    let result = \"\";\n    if (type.isArray) {\n        result += \"[]\";\n    }\n    if (type.isPointer) {\n        result += \"*\";\n    }\n    result += type.type;\n    return result;\n}\nfunction capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction jsonToGo(obj, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (typeof obj !== \"object\" || obj === null) {\n        return \"\";\n    }\n    if (seen.has(obj)) {\n        return \"\";\n    }\n    seen.add(obj);\n    const nestedStructs = [];\n    let struct = \"type \" + structName + \" struct {\\n\";\n    for (const [key, value] of Object.entries(obj)){\n        const fieldName = capitalizeFirst(key);\n        const goType = inferGoType(value, new Set(seen));\n        if (goType.type === \"struct\") {\n            const nestedStructName = structName + fieldName;\n            if (Array.isArray(value)) {\n                const elementValue = value[0];\n                if (elementValue && typeof elementValue === \"object\") {\n                    nestedStructs.push(jsonToGo(elementValue, nestedStructName, new Set(seen)));\n                    goType.type = nestedStructName;\n                }\n            } else {\n                nestedStructs.push(jsonToGo(value, nestedStructName, new Set(seen)));\n                goType.type = nestedStructName;\n            }\n        }\n        struct += \"\\t\" + fieldName + \" \" + formatGoFieldType(goType) + \" `json:\\\"\" + key + \"\\\"`\\n\";\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join(\"\") + struct;\n}\nfunction formatJSON(input) {\n    try {\n        const parsed = JSON.parse(input);\n        return JSON.stringify(parsed, null, 2);\n    } catch (e) {\n        return input;\n    }\n}\nfunction formatYAML(input) {\n    try {\n        const parsed = yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n        return yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stringify(parsed, {\n            indent: 2\n        });\n    } catch (e) {\n        return input;\n    }\n}\nconst sqlTypeMap = {\n    \"int\": {\n        mysql: \"int\",\n        postgres: \"int\",\n        sqlite: \"int\"\n    },\n    \"bigint\": {\n        mysql: \"int64\",\n        postgres: \"int64\",\n        sqlite: \"int64\"\n    },\n    \"tinyint\": {\n        mysql: \"int8\",\n        postgres: \"int8\",\n        sqlite: \"int8\"\n    },\n    \"smallint\": {\n        mysql: \"int16\",\n        postgres: \"int16\",\n        sqlite: \"int16\"\n    },\n    \"mediumint\": {\n        mysql: \"int32\",\n        postgres: \"int32\",\n        sqlite: \"int32\"\n    },\n    \"float\": {\n        mysql: \"float32\",\n        postgres: \"float32\",\n        sqlite: \"float32\"\n    },\n    \"double\": {\n        mysql: \"float64\",\n        postgres: \"float64\",\n        sqlite: \"float64\"\n    },\n    \"decimal\": {\n        mysql: \"float64\",\n        postgres: \"decimal.Decimal\",\n        sqlite: \"float64\"\n    },\n    \"varchar\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"char\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"text\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"mediumtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"longtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"datetime\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"timestamp\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"date\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"time\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"boolean\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"bool\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"json\": {\n        mysql: \"interface{}\",\n        postgres: \"interface{}\",\n        sqlite: \"interface{}\"\n    },\n    \"uuid\": {\n        mysql: \"string\",\n        postgres: \"uuid.UUID\",\n        sqlite: \"string\"\n    }\n};\nfunction generateTags(name, sqlType, options) {\n    const tags = [];\n    // 添加 json 标签\n    tags.push('json:\"'.concat(name, '\"'));\n    // 根据选择的标签类型添加对应的标签\n    switch(options.tagType){\n        case \"db\":\n            tags.push('db:\"'.concat(name, '\"'));\n            break;\n        case \"gorm\":\n            const gormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                gormTags.push(\"autoCreateTime\");\n            }\n            if (name === \"id\") {\n                gormTags.push(\"primaryKey\");\n            }\n            tags.push('gorm:\"'.concat(gormTags.join(';'), '\"'));\n            break;\n        case \"xorm\":\n            const xormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                xormTags.push(\"created\");\n            }\n            if (name === \"id\") {\n                xormTags.push(\"pk\");\n            }\n            tags.push('xorm:\"'.concat(xormTags.join(' '), '\"'));\n            break;\n    }\n    return tags.join(\" \");\n}\nfunction sqlToGoStruct(sql, options) {\n    const lines = sql.split(/\\r?\\n/);\n    let struct = \"type AutoGen struct {\\n\";\n    let hasTimeImport = false;\n    let hasDecimalImport = false;\n    let hasUUIDImport = false;\n    for (const line of lines){\n        const match = line.trim().match(/^([a-zA-Z0-9_]+)\\s+([a-zA-Z]+)(\\(\\d+\\))?/i);\n        if (match) {\n            var _sqlTypeMap_sqlType;\n            const [, name, type] = match;\n            const sqlType = type.toLowerCase();\n            const goType = ((_sqlTypeMap_sqlType = sqlTypeMap[sqlType]) === null || _sqlTypeMap_sqlType === void 0 ? void 0 : _sqlTypeMap_sqlType[options.dbType]) || \"interface{}\";\n            if (goType === \"time.Time\") {\n                hasTimeImport = true;\n            } else if (goType === \"decimal.Decimal\") {\n                hasDecimalImport = true;\n            } else if (goType === \"uuid.UUID\") {\n                hasUUIDImport = true;\n            }\n            const fieldName = capitalizeFirst(name);\n            const fieldType = options.usePointer && goType !== \"interface{}\" ? \"*\" + goType : goType;\n            const tags = generateTags(name, sqlType, options);\n            struct += \"\\t\" + fieldName + \" \" + fieldType + \" `\" + tags + \"`\\n\";\n        }\n    }\n    struct += \"}\\n\";\n    // 添加必要的导入\n    const imports = [];\n    if (hasTimeImport) {\n        imports.push('time');\n    }\n    if (hasDecimalImport) {\n        imports.push('github.com/shopspring/decimal');\n    }\n    if (hasUUIDImport) {\n        imports.push('github.com/google/uuid');\n    }\n    if (imports.length > 0) {\n        struct = 'import (\\n\\t\"' + imports.join('\"\\n\\t\"') + '\"\\n)\\n\\n' + struct;\n    }\n    return struct;\n}\nconst SQL_TEMPLATE = \"-- 用户表示例\\nid bigint\\nusername varchar(255)\\nemail varchar(255)\\npassword varchar(255)\\nage int\\ncreated_at datetime\\nupdated_at timestamp\\nis_active boolean\\nprofile_data json\\n\";\n// 添加格式校验函数\nfunction validateFormat(input, type) {\n    if (!input.trim()) {\n        return {\n            isValid: false,\n            error: \"输入内容为空\"\n        };\n    }\n    try {\n        switch(type){\n            case 'json':\n                JSON.parse(input);\n                return {\n                    isValid: true\n                };\n            case 'yaml':\n                yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n                return {\n                    isValid: true\n                };\n            case 'sql':\n                const sqlLines = input.split(/\\r?\\n/).filter((line)=>line.trim() && !line.startsWith('--'));\n                if (sqlLines.length === 0) {\n                    return {\n                        isValid: false,\n                        error: \"没有找到有效的 SQL 字段定义\"\n                    };\n                }\n                for (const line of sqlLines){\n                    const match = line.trim().match(/^[a-zA-Z0-9_]+\\s+[a-zA-Z]+(\\(\\d+\\))?$/i);\n                    if (!match) {\n                        return {\n                            isValid: false,\n                            error: \"无效的 SQL 字段定义: \".concat(line)\n                        };\n                    }\n                }\n                return {\n                    isValid: true\n                };\n            case 'proto':\n                if (!input.includes('message')) {\n                    return {\n                        isValid: false,\n                        error: \"未找到 message 定义\"\n                    };\n                }\n                return {\n                    isValid: true\n                };\n            case 'xml':\n                new DOMParser().parseFromString(input, 'text/xml');\n                return {\n                    isValid: true\n                };\n            case 'csv':\n                const csvLines = input.split(/\\r?\\n/).filter((line)=>line.trim());\n                if (csvLines.length < 2) {\n                    return {\n                        isValid: false,\n                        error: \"CSV 至少需要包含标题行和一行数据\"\n                    };\n                }\n                return {\n                    isValid: true\n                };\n            default:\n                return {\n                    isValid: false,\n                    error: \"不支持的格式类型\"\n                };\n        }\n    } catch (e) {\n        return {\n            isValid: false,\n            error: \"格式错误: \".concat(e instanceof Error ? e.message : '未知错误')\n        };\n    }\n}\n// 添加示例模板\nconst TEMPLATES = {\n    json: '{\\n  \"id\": 1,\\n  \"name\": \"example\",\\n  \"age\": 25,\\n  \"email\": \"test@example.com\",\\n  \"is_active\": true,\\n  \"created_at\": \"2024-03-21T12:00:00Z\",\\n  \"tags\": [\"tag1\", \"tag2\"],\\n  \"profile\": {\\n    \"address\": \"123 Street\",\\n    \"phone\": \"1234567890\"\\n  }\\n}',\n    yaml: 'id: 1\\nname: example\\nage: 25\\nemail: test@example.com\\nis_active: true\\ncreated_at: 2024-03-21T12:00:00Z\\ntags:\\n  - tag1\\n  - tag2\\nprofile:\\n  address: 123 Street\\n  phone: \"1234567890\"',\n    sql: SQL_TEMPLATE,\n    proto: 'syntax = \"proto3\";\\n\\npackage example;\\n\\nmessage User {\\n  int64 id = 1;\\n  string name = 2;\\n  int32 age = 3;\\n  string email = 4;\\n  bool is_active = 5;\\n  string created_at = 6;\\n  repeated string tags = 7;\\n  Profile profile = 8;\\n}\\n\\nmessage Profile {\\n  string address = 1;\\n  string phone = 2;\\n}',\n    xml: '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<user>\\n  <id>1</id>\\n  <name>example</name>\\n  <age>25</age>\\n  <email>test@example.com</email>\\n  <is_active>true</is_active>\\n  <created_at>2024-03-21T12:00:00Z</created_at>\\n  <tags>\\n    <tag>tag1</tag>\\n    <tag>tag2</tag>\\n  </tags>\\n  <profile>\\n    <address>123 Street</address>\\n    <phone>1234567890</phone>\\n  </profile>\\n</user>',\n    csv: \"id,name,age,email,is_active,created_at\\n1,example,25,test@example.com,true,2024-03-21T12:00:00Z\"\n};\n// Proto 转 Go 结构体\nfunction protoToGo(proto) {\n    const lines = proto.split(/\\r?\\n/);\n    let output = \"\";\n    let currentMessage = \"\";\n    let imports = new Set();\n    for (const line of lines){\n        // 忽略空行和 proto 语法声明\n        if (!line.trim() || line.includes('syntax') || line.includes('package')) {\n            continue;\n        }\n        // 处理消息定义\n        if (line.includes('message')) {\n            var _line_match;\n            if (currentMessage) {\n                output += \"}\\n\\n\";\n            }\n            const messageName = (_line_match = line.match(/message\\s+(\\w+)/)) === null || _line_match === void 0 ? void 0 : _line_match[1];\n            if (messageName) {\n                currentMessage = messageName;\n                output += \"type \".concat(messageName, \" struct {\\n\");\n            }\n            continue;\n        }\n        // 处理字段\n        if (currentMessage && line.trim()) {\n            const fieldMatch = line.match(/\\s*(repeated)?\\s*(\\w+)\\s+(\\w+)\\s*=\\s*\\d+;/);\n            if (fieldMatch) {\n                const [, repeated, type, name] = fieldMatch;\n                const goType = protoTypeToGo(type);\n                const fieldName = capitalizeFirst(name);\n                const fieldType = repeated ? \"[]\".concat(goType) : goType;\n                if (goType === \"time.Time\") {\n                    imports.add('time');\n                }\n                output += \"\t\".concat(fieldName, \" \").concat(fieldType, ' `json:\"').concat(name, '\"`\\n');\n            }\n        }\n    }\n    if (currentMessage) {\n        output += \"}\\n\";\n    }\n    if (imports.size > 0) {\n        output = 'import (\\n\\t\"' + Array.from(imports).join('\"\\n\\t\"') + '\"\\n)\\n\\n' + output;\n    }\n    return output;\n}\n// Proto 类型转 Go 类型\nfunction protoTypeToGo(type) {\n    const typeMap = {\n        'double': 'float64',\n        'float': 'float32',\n        'int32': 'int32',\n        'int64': 'int64',\n        'uint32': 'uint32',\n        'uint64': 'uint64',\n        'sint32': 'int32',\n        'sint64': 'int64',\n        'fixed32': 'uint32',\n        'fixed64': 'uint64',\n        'sfixed32': 'int32',\n        'sfixed64': 'int64',\n        'bool': 'bool',\n        'string': 'string',\n        'bytes': '[]byte',\n        'Timestamp': 'time.Time'\n    };\n    return typeMap[type] || type;\n}\n// XML 转 Go 结构体\nfunction xmlToGo(xml) {\n    try {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(xml, 'text/xml');\n        const root = doc.documentElement;\n        return processXMLNode(root, capitalizeFirst(root.tagName));\n    } catch (e) {\n        throw new Error('XML 解析错误');\n    }\n}\nfunction processXMLNode(node, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (seen.has(structName)) {\n        return '';\n    }\n    seen.add(structName);\n    let struct = \"type \".concat(structName, \" struct {\\n\");\n    const nestedStructs = [];\n    const fields = new Map();\n    // 处理子元素\n    for (const child of Array.from(node.children)){\n        const fieldName = capitalizeFirst(child.tagName);\n        const existingField = fields.get(fieldName);\n        if (child.children.length === 0 || child.children.length === 1 && child.children[0].nodeType === 3) {\n            var _child_textContent;\n            // 简单值\n            const value = ((_child_textContent = child.textContent) === null || _child_textContent === void 0 ? void 0 : _child_textContent.trim()) || '';\n            const type = inferTypeFromValue(value);\n            if (existingField) {\n                existingField.isArray = true;\n            } else {\n                fields.set(fieldName, {\n                    type,\n                    isArray: false\n                });\n            }\n        } else {\n            // 复杂类型\n            const nestedStructName = structName + fieldName;\n            nestedStructs.push(processXMLNode(child, nestedStructName, seen));\n            if (existingField) {\n                existingField.isArray = true;\n            } else {\n                fields.set(fieldName, {\n                    type: nestedStructName,\n                    isArray: false\n                });\n            }\n        }\n    }\n    // 生成字段\n    for (const [fieldName, { type, isArray }] of fields){\n        const fieldType = isArray ? \"[]\".concat(type) : type;\n        struct += \"\t\".concat(fieldName, \" \").concat(fieldType, ' `xml:\"').concat(fieldName.toLowerCase(), '\" json:\"').concat(fieldName.toLowerCase(), '\"`\\n');\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join('') + struct;\n}\nfunction inferTypeFromValue(value) {\n    if (value === 'true' || value === 'false') return 'bool';\n    if (/^\\d+$/.test(value)) return 'int';\n    if (/^\\d*\\.\\d+$/.test(value)) return 'float64';\n    if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)) return 'time.Time';\n    return 'string';\n}\n// CSV 转 Go 结构体\nfunction csvToGo(csv) {\n    const lines = csv.split(/\\r?\\n/).filter((line)=>line.trim());\n    if (lines.length < 2) {\n        throw new Error('CSV 至少需要包含标题行和一行数据');\n    }\n    const headers = lines[0].split(',').map((h)=>h.trim());\n    const firstRow = lines[1].split(',').map((v)=>v.trim());\n    let struct = \"type AutoGen struct {\\n\";\n    for(let i = 0; i < headers.length; i++){\n        const fieldName = capitalizeFirst(headers[i]);\n        const value = firstRow[i];\n        const type = inferTypeFromValue(value);\n        struct += \"\t\".concat(fieldName, \" \").concat(type, ' `json:\"').concat(headers[i], '\"`\\n');\n    }\n    struct += \"}\\n\";\n    return struct;\n}\n// 导出新的转换函数\nfunction convertToGo(input, type, options) {\n    switch(type){\n        case 'json':\n            return jsonToGo(JSON.parse(input), 'AutoGen');\n        case 'yaml':\n            return jsonToGo(yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input), 'AutoGen');\n        case 'sql':\n            return sqlToGoStruct(input, options);\n        case 'proto':\n            return protoToGo(input);\n        case 'xml':\n            return xmlToGo(input);\n        case 'csv':\n            return csvToGo(input);\n        default:\n            throw new Error('不支持的格式类型');\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0RBQVUsQ0FBQzRDO1FBQzFCLE9BQU81QyxzREFBYyxDQUFDNkMsUUFBUTtZQUFFSyxRQUFRO1FBQUU7SUFDNUMsRUFBRSxVQUFNO1FBQ04sT0FBT047SUFDVDtBQUNGO0FBRUEsTUFBTU8sYUFBcUQ7SUFDekQsT0FBTztRQUNMQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsVUFBVTtRQUNSRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsYUFBYTtRQUNYRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsU0FBUztRQUNQRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsVUFBVTtRQUNSRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsY0FBYztRQUNaRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsYUFBYTtRQUNYRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixP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SztZQUNILE9BQU93QyxVQUFVdEQ7UUFDbkIsS0FBSztZQUNILE9BQU9nRSxRQUFRaEU7UUFDakIsS0FBSztZQUNILE9BQU9tRixRQUFRbkY7UUFDakI7WUFDRSxNQUFNLElBQUk4QyxNQUFNO0lBQ3BCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXphenovRG93bmxvYWRzL2pzb24tdG8tZ28tdmVyY2VsL3BhZ2VzL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBZQU1MIGZyb20gJ3lhbWwnO1xuaW1wb3J0IHsgU1FMT3B0aW9ucywgREJUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBHb1R5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGlzUG9pbnRlcjogYm9vbGVhbjtcbiAgaXNBcnJheTogYm9vbGVhbjtcbiAgZWxlbWVudFR5cGU/OiBHb1R5cGU7XG59XG5cbmZ1bmN0aW9uIGluZmVyR29UeXBlKHZhbHVlOiBhbnksIHNlZW4gPSBuZXcgU2V0PGFueT4oKSk6IEdvVHlwZSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IHRydWUsIGlzQXJyYXk6IGZhbHNlIH07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImludGVyZmFjZXt9XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IHRydWUgfTtcbiAgICB9XG4gICAgLy8g5YiG5p6Q5pWw57uE5Lit55qE5omA5pyJ5YWD57Sg57G75Z6LXG4gICAgY29uc3QgZWxlbWVudFR5cGVzID0gdmFsdWUubWFwKGl0ZW0gPT4gaW5mZXJHb1R5cGUoaXRlbSwgc2VlbikpO1xuICAgIC8vIOWmguaenOaJgOacieWFg+e0oOexu+Wei+ebuOWQjO+8jOS9v+eUqOivpeexu+Wei++8m+WQpuWImeS9v+eUqCBpbnRlcmZhY2V7fVxuICAgIGNvbnN0IGlzU2FtZVR5cGUgPSBlbGVtZW50VHlwZXMuZXZlcnkodCA9PiBcbiAgICAgIHQudHlwZSA9PT0gZWxlbWVudFR5cGVzWzBdLnR5cGUgJiYgXG4gICAgICB0LmlzUG9pbnRlciA9PT0gZWxlbWVudFR5cGVzWzBdLmlzUG9pbnRlclxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGlzU2FtZVR5cGUgPyBlbGVtZW50VHlwZXNbMF0udHlwZSA6IFwiaW50ZXJmYWNle31cIixcbiAgICAgIGlzUG9pbnRlcjogaXNTYW1lVHlwZSA/IGVsZW1lbnRUeXBlc1swXS5pc1BvaW50ZXIgOiBmYWxzZSxcbiAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICBlbGVtZW50VHlwZTogaXNTYW1lVHlwZSA/IGVsZW1lbnRUeXBlc1swXSA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDIxNDc0ODM2NDcgfHwgdmFsdWUgPCAtMjE0NzQ4MzY0OCkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50NjRcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImludFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJmbG9hdDY0XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IHRydWUsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cnVjdFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImludGVyZmFjZXt9XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0R29GaWVsZFR5cGUodHlwZTogR29UeXBlKTogc3RyaW5nIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGlmICh0eXBlLmlzQXJyYXkpIHtcbiAgICByZXN1bHQgKz0gXCJbXVwiO1xuICB9XG4gIGlmICh0eXBlLmlzUG9pbnRlcikge1xuICAgIHJlc3VsdCArPSBcIipcIjtcbiAgfVxuICByZXN1bHQgKz0gdHlwZS50eXBlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplRmlyc3Qoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24ganNvblRvR28ob2JqOiBhbnksIHN0cnVjdE5hbWU6IHN0cmluZywgc2VlbiA9IG5ldyBTZXQ8YW55PigpKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBpZiAoc2Vlbi5oYXMob2JqKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHNlZW4uYWRkKG9iaik7XG5cbiAgY29uc3QgbmVzdGVkU3RydWN0czogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHN0cnVjdCA9IFwidHlwZSBcIiArIHN0cnVjdE5hbWUgKyBcIiBzdHJ1Y3Qge1xcblwiO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBjb25zdCBmaWVsZE5hbWUgPSBjYXBpdGFsaXplRmlyc3Qoa2V5KTtcbiAgICBjb25zdCBnb1R5cGUgPSBpbmZlckdvVHlwZSh2YWx1ZSwgbmV3IFNldChzZWVuKSk7XG5cbiAgICBpZiAoZ29UeXBlLnR5cGUgPT09IFwic3RydWN0XCIpIHtcbiAgICAgIGNvbnN0IG5lc3RlZFN0cnVjdE5hbWUgPSBzdHJ1Y3ROYW1lICsgZmllbGROYW1lO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICBpZiAoZWxlbWVudFZhbHVlICYmIHR5cGVvZiBlbGVtZW50VmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBuZXN0ZWRTdHJ1Y3RzLnB1c2goanNvblRvR28oZWxlbWVudFZhbHVlLCBuZXN0ZWRTdHJ1Y3ROYW1lLCBuZXcgU2V0KHNlZW4pKSk7XG4gICAgICAgICAgZ29UeXBlLnR5cGUgPSBuZXN0ZWRTdHJ1Y3ROYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXN0ZWRTdHJ1Y3RzLnB1c2goanNvblRvR28odmFsdWUsIG5lc3RlZFN0cnVjdE5hbWUsIG5ldyBTZXQoc2VlbikpKTtcbiAgICAgICAgZ29UeXBlLnR5cGUgPSBuZXN0ZWRTdHJ1Y3ROYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0cnVjdCArPSBcIlxcdFwiICsgZmllbGROYW1lICsgXCIgXCIgKyBmb3JtYXRHb0ZpZWxkVHlwZShnb1R5cGUpICsgXCIgYGpzb246XFxcIlwiICsga2V5ICsgXCJcXFwiYFxcblwiO1xuICB9XG5cbiAgc3RydWN0ICs9IFwifVxcblxcblwiO1xuICByZXR1cm4gbmVzdGVkU3RydWN0cy5qb2luKFwiXCIpICsgc3RydWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SlNPTihpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRZQU1MKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IFlBTUwucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiBZQU1MLnN0cmluZ2lmeShwYXJzZWQsIHsgaW5kZW50OiAyIH0pO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbn1cblxuY29uc3Qgc3FsVHlwZU1hcDogUmVjb3JkPHN0cmluZywgUmVjb3JkPERCVHlwZSwgc3RyaW5nPj4gPSB7XG4gIFwiaW50XCI6IHtcbiAgICBteXNxbDogXCJpbnRcIixcbiAgICBwb3N0Z3JlczogXCJpbnRcIixcbiAgICBzcWxpdGU6IFwiaW50XCIsXG4gIH0sXG4gIFwiYmlnaW50XCI6IHtcbiAgICBteXNxbDogXCJpbnQ2NFwiLFxuICAgIHBvc3RncmVzOiBcImludDY0XCIsXG4gICAgc3FsaXRlOiBcImludDY0XCIsXG4gIH0sXG4gIFwidGlueWludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50OFwiLFxuICAgIHBvc3RncmVzOiBcImludDhcIixcbiAgICBzcWxpdGU6IFwiaW50OFwiLFxuICB9LFxuICBcInNtYWxsaW50XCI6IHtcbiAgICBteXNxbDogXCJpbnQxNlwiLFxuICAgIHBvc3RncmVzOiBcImludDE2XCIsXG4gICAgc3FsaXRlOiBcImludDE2XCIsXG4gIH0sXG4gIFwibWVkaXVtaW50XCI6IHtcbiAgICBteXNxbDogXCJpbnQzMlwiLFxuICAgIHBvc3RncmVzOiBcImludDMyXCIsXG4gICAgc3FsaXRlOiBcImludDMyXCIsXG4gIH0sXG4gIFwiZmxvYXRcIjoge1xuICAgIG15c3FsOiBcImZsb2F0MzJcIixcbiAgICBwb3N0Z3JlczogXCJmbG9hdDMyXCIsXG4gICAgc3FsaXRlOiBcImZsb2F0MzJcIixcbiAgfSxcbiAgXCJkb3VibGVcIjoge1xuICAgIG15c3FsOiBcImZsb2F0NjRcIixcbiAgICBwb3N0Z3JlczogXCJmbG9hdDY0XCIsXG4gICAgc3FsaXRlOiBcImZsb2F0NjRcIixcbiAgfSxcbiAgXCJkZWNpbWFsXCI6IHtcbiAgICBteXNxbDogXCJmbG9hdDY0XCIsXG4gICAgcG9zdGdyZXM6IFwiZGVjaW1hbC5EZWNpbWFsXCIsXG4gICAgc3FsaXRlOiBcImZsb2F0NjRcIixcbiAgfSxcbiAgXCJ2YXJjaGFyXCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwiY2hhclwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcInRleHRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJtZWRpdW10ZXh0XCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwibG9uZ3RleHRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJkYXRldGltZVwiOiB7XG4gICAgbXlzcWw6IFwidGltZS5UaW1lXCIsXG4gICAgcG9zdGdyZXM6IFwidGltZS5UaW1lXCIsXG4gICAgc3FsaXRlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcInRpbWVzdGFtcFwiOiB7XG4gICAgbXlzcWw6IFwidGltZS5UaW1lXCIsXG4gICAgcG9zdGdyZXM6IFwidGltZS5UaW1lXCIsXG4gICAgc3FsaXRlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcImRhdGVcIjoge1xuICAgIG15c3FsOiBcInRpbWUuVGltZVwiLFxuICAgIHBvc3RncmVzOiBcInRpbWUuVGltZVwiLFxuICAgIHNxbGl0ZTogXCJ0aW1lLlRpbWVcIixcbiAgfSxcbiAgXCJ0aW1lXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gIH0sXG4gIFwiYm9vbGVhblwiOiB7XG4gICAgbXlzcWw6IFwiYm9vbFwiLFxuICAgIHBvc3RncmVzOiBcImJvb2xcIixcbiAgICBzcWxpdGU6IFwiYm9vbFwiLFxuICB9LFxuICBcImJvb2xcIjoge1xuICAgIG15c3FsOiBcImJvb2xcIixcbiAgICBwb3N0Z3JlczogXCJib29sXCIsXG4gICAgc3FsaXRlOiBcImJvb2xcIixcbiAgfSxcbiAgXCJqc29uXCI6IHtcbiAgICBteXNxbDogXCJpbnRlcmZhY2V7fVwiLFxuICAgIHBvc3RncmVzOiBcImludGVyZmFjZXt9XCIsXG4gICAgc3FsaXRlOiBcImludGVyZmFjZXt9XCIsXG4gIH0sXG4gIFwidXVpZFwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwidXVpZC5VVUlEXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUYWdzKG5hbWU6IHN0cmluZywgc3FsVHlwZTogc3RyaW5nLCBvcHRpb25zOiBTUUxPcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3QgdGFnczogc3RyaW5nW10gPSBbXTtcblxuICAvLyDmt7vliqAganNvbiDmoIfnrb5cbiAgdGFncy5wdXNoKGBqc29uOlwiJHtuYW1lfVwiYCk7XG5cbiAgLy8g5qC55o2u6YCJ5oup55qE5qCH562+57G75Z6L5re75Yqg5a+55bqU55qE5qCH562+XG4gIHN3aXRjaCAob3B0aW9ucy50YWdUeXBlKSB7XG4gICAgY2FzZSBcImRiXCI6XG4gICAgICB0YWdzLnB1c2goYGRiOlwiJHtuYW1lfVwiYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZ29ybVwiOlxuICAgICAgY29uc3QgZ29ybVRhZ3M6IHN0cmluZ1tdID0gW25hbWVdO1xuICAgICAgaWYgKHNxbFR5cGUgPT09IFwiZGF0ZXRpbWVcIiB8fCBzcWxUeXBlID09PSBcInRpbWVzdGFtcFwiKSB7XG4gICAgICAgIGdvcm1UYWdzLnB1c2goXCJhdXRvQ3JlYXRlVGltZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgICAgICAgZ29ybVRhZ3MucHVzaChcInByaW1hcnlLZXlcIik7XG4gICAgICB9XG4gICAgICB0YWdzLnB1c2goYGdvcm06XCIke2dvcm1UYWdzLmpvaW4oJzsnKX1cImApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhvcm1cIjpcbiAgICAgIGNvbnN0IHhvcm1UYWdzOiBzdHJpbmdbXSA9IFtuYW1lXTtcbiAgICAgIGlmIChzcWxUeXBlID09PSBcImRhdGV0aW1lXCIgfHwgc3FsVHlwZSA9PT0gXCJ0aW1lc3RhbXBcIikge1xuICAgICAgICB4b3JtVGFncy5wdXNoKFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgICAgICAgeG9ybVRhZ3MucHVzaChcInBrXCIpO1xuICAgICAgfVxuICAgICAgdGFncy5wdXNoKGB4b3JtOlwiJHt4b3JtVGFncy5qb2luKCcgJyl9XCJgKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRhZ3Muam9pbihcIiBcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcWxUb0dvU3RydWN0KHNxbDogc3RyaW5nLCBvcHRpb25zOiBTUUxPcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3QgbGluZXMgPSBzcWwuc3BsaXQoL1xccj9cXG4vKTtcbiAgbGV0IHN0cnVjdCA9IFwidHlwZSBBdXRvR2VuIHN0cnVjdCB7XFxuXCI7XG4gIGxldCBoYXNUaW1lSW1wb3J0ID0gZmFsc2U7XG4gIGxldCBoYXNEZWNpbWFsSW1wb3J0ID0gZmFsc2U7XG4gIGxldCBoYXNVVUlESW1wb3J0ID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLnRyaW0oKS5tYXRjaCgvXihbYS16QS1aMC05X10rKVxccysoW2EtekEtWl0rKShcXChcXGQrXFwpKT8vaSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBuYW1lLCB0eXBlXSA9IG1hdGNoO1xuICAgICAgY29uc3Qgc3FsVHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGdvVHlwZSA9IHNxbFR5cGVNYXBbc3FsVHlwZV0/LltvcHRpb25zLmRiVHlwZV0gfHwgXCJpbnRlcmZhY2V7fVwiO1xuXG4gICAgICBpZiAoZ29UeXBlID09PSBcInRpbWUuVGltZVwiKSB7XG4gICAgICAgIGhhc1RpbWVJbXBvcnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChnb1R5cGUgPT09IFwiZGVjaW1hbC5EZWNpbWFsXCIpIHtcbiAgICAgICAgaGFzRGVjaW1hbEltcG9ydCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdvVHlwZSA9PT0gXCJ1dWlkLlVVSURcIikge1xuICAgICAgICBoYXNVVUlESW1wb3J0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmllbGROYW1lID0gY2FwaXRhbGl6ZUZpcnN0KG5hbWUpO1xuICAgICAgY29uc3QgZmllbGRUeXBlID0gb3B0aW9ucy51c2VQb2ludGVyICYmIGdvVHlwZSAhPT0gXCJpbnRlcmZhY2V7fVwiID8gXCIqXCIgKyBnb1R5cGUgOiBnb1R5cGU7XG4gICAgICBjb25zdCB0YWdzID0gZ2VuZXJhdGVUYWdzKG5hbWUsIHNxbFR5cGUsIG9wdGlvbnMpO1xuICAgICAgc3RydWN0ICs9IFwiXFx0XCIgKyBmaWVsZE5hbWUgKyBcIiBcIiArIGZpZWxkVHlwZSArIFwiIGBcIiArIHRhZ3MgKyBcImBcXG5cIjtcbiAgICB9XG4gIH1cblxuICBzdHJ1Y3QgKz0gXCJ9XFxuXCI7XG5cbiAgLy8g5re75Yqg5b+F6KaB55qE5a+85YWlXG4gIGNvbnN0IGltcG9ydHM6IHN0cmluZ1tdID0gW107XG4gIGlmIChoYXNUaW1lSW1wb3J0KSB7XG4gICAgaW1wb3J0cy5wdXNoKCd0aW1lJyk7XG4gIH1cbiAgaWYgKGhhc0RlY2ltYWxJbXBvcnQpIHtcbiAgICBpbXBvcnRzLnB1c2goJ2dpdGh1Yi5jb20vc2hvcHNwcmluZy9kZWNpbWFsJyk7XG4gIH1cbiAgaWYgKGhhc1VVSURJbXBvcnQpIHtcbiAgICBpbXBvcnRzLnB1c2goJ2dpdGh1Yi5jb20vZ29vZ2xlL3V1aWQnKTtcbiAgfVxuXG4gIGlmIChpbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICBzdHJ1Y3QgPSAnaW1wb3J0IChcXG5cXHRcIicgKyBpbXBvcnRzLmpvaW4oJ1wiXFxuXFx0XCInKSArICdcIlxcbilcXG5cXG4nICsgc3RydWN0O1xuICB9XG5cbiAgcmV0dXJuIHN0cnVjdDtcbn1cblxuZXhwb3J0IGNvbnN0IFNRTF9URU1QTEFURSA9IGAtLSDnlKjmiLfooajnpLrkvotcbmlkIGJpZ2ludFxudXNlcm5hbWUgdmFyY2hhcigyNTUpXG5lbWFpbCB2YXJjaGFyKDI1NSlcbnBhc3N3b3JkIHZhcmNoYXIoMjU1KVxuYWdlIGludFxuY3JlYXRlZF9hdCBkYXRldGltZVxudXBkYXRlZF9hdCB0aW1lc3RhbXBcbmlzX2FjdGl2ZSBib29sZWFuXG5wcm9maWxlX2RhdGEganNvblxuYDtcblxuLy8g5re75Yqg5qC85byP5qCh6aqM5Ye95pWwXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoaW5wdXQ6IHN0cmluZywgdHlwZTogJ2pzb24nIHwgJ3lhbWwnIHwgJ3NxbCcgfCAncHJvdG8nIHwgJ3htbCcgfCAnY3N2Jyk6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIGlmICghaW5wdXQudHJpbSgpKSB7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIui+k+WFpeWGheWuueS4uuepulwiIH07XG4gIH1cblxuICB0cnkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gICAgICBjYXNlICd5YW1sJzpcbiAgICAgICAgWUFNTC5wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGNhc2UgJ3NxbCc6XG4gICAgICAgIGNvbnN0IHNxbExpbmVzID0gaW5wdXQuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAmJiAhbGluZS5zdGFydHNXaXRoKCctLScpKTtcbiAgICAgICAgaWYgKHNxbExpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCLmsqHmnInmib7liLDmnInmlYjnmoQgU1FMIOWtl+auteWumuS5iVwiIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHNxbExpbmVzKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLnRyaW0oKS5tYXRjaCgvXlthLXpBLVowLTlfXStcXHMrW2EtekEtWl0rKFxcKFxcZCtcXCkpPyQvaSk7XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBg5peg5pWI55qEIFNRTCDlrZfmrrXlrprkuYk6ICR7bGluZX1gIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGNhc2UgJ3Byb3RvJzpcbiAgICAgICAgaWYgKCFpbnB1dC5pbmNsdWRlcygnbWVzc2FnZScpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIuacquaJvuWIsCBtZXNzYWdlIOWumuS5iVwiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhpbnB1dCwgJ3RleHQveG1sJyk7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGNhc2UgJ2Nzdic6XG4gICAgICAgIGNvbnN0IGNzdkxpbmVzID0gaW5wdXQuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgICAgIGlmIChjc3ZMaW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIkNTViDoh7PlsJHpnIDopoHljIXlkKvmoIfpopjooYzlkozkuIDooYzmlbDmja5cIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCLkuI3mlK/mjIHnmoTmoLzlvI/nsbvlnotcIiB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogYOagvOW8j+mUmeivrzogJHtlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAn5pyq55+l6ZSZ6K+vJ31gIH07XG4gIH1cbn1cblxuLy8g5re75Yqg56S65L6L5qih5p2/XG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0ge1xuICBqc29uOiBge1xuICBcImlkXCI6IDEsXG4gIFwibmFtZVwiOiBcImV4YW1wbGVcIixcbiAgXCJhZ2VcIjogMjUsXG4gIFwiZW1haWxcIjogXCJ0ZXN0QGV4YW1wbGUuY29tXCIsXG4gIFwiaXNfYWN0aXZlXCI6IHRydWUsXG4gIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDMtMjFUMTI6MDA6MDBaXCIsXG4gIFwidGFnc1wiOiBbXCJ0YWcxXCIsIFwidGFnMlwiXSxcbiAgXCJwcm9maWxlXCI6IHtcbiAgICBcImFkZHJlc3NcIjogXCIxMjMgU3RyZWV0XCIsXG4gICAgXCJwaG9uZVwiOiBcIjEyMzQ1Njc4OTBcIlxuICB9XG59YCxcbiAgeWFtbDogYGlkOiAxXG5uYW1lOiBleGFtcGxlXG5hZ2U6IDI1XG5lbWFpbDogdGVzdEBleGFtcGxlLmNvbVxuaXNfYWN0aXZlOiB0cnVlXG5jcmVhdGVkX2F0OiAyMDI0LTAzLTIxVDEyOjAwOjAwWlxudGFnczpcbiAgLSB0YWcxXG4gIC0gdGFnMlxucHJvZmlsZTpcbiAgYWRkcmVzczogMTIzIFN0cmVldFxuICBwaG9uZTogXCIxMjM0NTY3ODkwXCJgLFxuICBzcWw6IFNRTF9URU1QTEFURSxcbiAgcHJvdG86IGBzeW50YXggPSBcInByb3RvM1wiO1xuXG5wYWNrYWdlIGV4YW1wbGU7XG5cbm1lc3NhZ2UgVXNlciB7XG4gIGludDY0IGlkID0gMTtcbiAgc3RyaW5nIG5hbWUgPSAyO1xuICBpbnQzMiBhZ2UgPSAzO1xuICBzdHJpbmcgZW1haWwgPSA0O1xuICBib29sIGlzX2FjdGl2ZSA9IDU7XG4gIHN0cmluZyBjcmVhdGVkX2F0ID0gNjtcbiAgcmVwZWF0ZWQgc3RyaW5nIHRhZ3MgPSA3O1xuICBQcm9maWxlIHByb2ZpbGUgPSA4O1xufVxuXG5tZXNzYWdlIFByb2ZpbGUge1xuICBzdHJpbmcgYWRkcmVzcyA9IDE7XG4gIHN0cmluZyBwaG9uZSA9IDI7XG59YCxcbiAgeG1sOiBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG48dXNlcj5cbiAgPGlkPjE8L2lkPlxuICA8bmFtZT5leGFtcGxlPC9uYW1lPlxuICA8YWdlPjI1PC9hZ2U+XG4gIDxlbWFpbD50ZXN0QGV4YW1wbGUuY29tPC9lbWFpbD5cbiAgPGlzX2FjdGl2ZT50cnVlPC9pc19hY3RpdmU+XG4gIDxjcmVhdGVkX2F0PjIwMjQtMDMtMjFUMTI6MDA6MDBaPC9jcmVhdGVkX2F0PlxuICA8dGFncz5cbiAgICA8dGFnPnRhZzE8L3RhZz5cbiAgICA8dGFnPnRhZzI8L3RhZz5cbiAgPC90YWdzPlxuICA8cHJvZmlsZT5cbiAgICA8YWRkcmVzcz4xMjMgU3RyZWV0PC9hZGRyZXNzPlxuICAgIDxwaG9uZT4xMjM0NTY3ODkwPC9waG9uZT5cbiAgPC9wcm9maWxlPlxuPC91c2VyPmAsXG4gIGNzdjogYGlkLG5hbWUsYWdlLGVtYWlsLGlzX2FjdGl2ZSxjcmVhdGVkX2F0XG4xLGV4YW1wbGUsMjUsdGVzdEBleGFtcGxlLmNvbSx0cnVlLDIwMjQtMDMtMjFUMTI6MDA6MDBaYFxufTtcblxuLy8gUHJvdG8g6L2sIEdvIOe7k+aehOS9k1xuZnVuY3Rpb24gcHJvdG9Ub0dvKHByb3RvOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lcyA9IHByb3RvLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBvdXRwdXQgPSBcIlwiO1xuICBsZXQgY3VycmVudE1lc3NhZ2UgPSBcIlwiO1xuICBsZXQgaW1wb3J0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIC8vIOW/veeVpeepuuihjOWSjCBwcm90byDor63ms5Xlo7DmmI5cbiAgICBpZiAoIWxpbmUudHJpbSgpIHx8IGxpbmUuaW5jbHVkZXMoJ3N5bnRheCcpIHx8IGxpbmUuaW5jbHVkZXMoJ3BhY2thZ2UnKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8g5aSE55CG5raI5oGv5a6a5LmJXG4gICAgaWYgKGxpbmUuaW5jbHVkZXMoJ21lc3NhZ2UnKSkge1xuICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICAgIG91dHB1dCArPSBcIn1cXG5cXG5cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VOYW1lID0gbGluZS5tYXRjaCgvbWVzc2FnZVxccysoXFx3KykvKT8uWzFdO1xuICAgICAgaWYgKG1lc3NhZ2VOYW1lKSB7XG4gICAgICAgIGN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZU5hbWU7XG4gICAgICAgIG91dHB1dCArPSBgdHlwZSAke21lc3NhZ2VOYW1lfSBzdHJ1Y3Qge1xcbmA7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyDlpITnkIblrZfmrrVcbiAgICBpZiAoY3VycmVudE1lc3NhZ2UgJiYgbGluZS50cmltKCkpIHtcbiAgICAgIGNvbnN0IGZpZWxkTWF0Y2ggPSBsaW5lLm1hdGNoKC9cXHMqKHJlcGVhdGVkKT9cXHMqKFxcdyspXFxzKyhcXHcrKVxccyo9XFxzKlxcZCs7Lyk7XG4gICAgICBpZiAoZmllbGRNYXRjaCkge1xuICAgICAgICBjb25zdCBbLCByZXBlYXRlZCwgdHlwZSwgbmFtZV0gPSBmaWVsZE1hdGNoO1xuICAgICAgICBjb25zdCBnb1R5cGUgPSBwcm90b1R5cGVUb0dvKHR5cGUpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBjYXBpdGFsaXplRmlyc3QobmFtZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHJlcGVhdGVkID8gYFtdJHtnb1R5cGV9YCA6IGdvVHlwZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChnb1R5cGUgPT09IFwidGltZS5UaW1lXCIpIHtcbiAgICAgICAgICBpbXBvcnRzLmFkZCgndGltZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IGBcXHQke2ZpZWxkTmFtZX0gJHtmaWVsZFR5cGV9IFxcYGpzb246XCIke25hbWV9XCJcXGBcXG5gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50TWVzc2FnZSkge1xuICAgIG91dHB1dCArPSBcIn1cXG5cIjtcbiAgfVxuXG4gIGlmIChpbXBvcnRzLnNpemUgPiAwKSB7XG4gICAgb3V0cHV0ID0gJ2ltcG9ydCAoXFxuXFx0XCInICsgQXJyYXkuZnJvbShpbXBvcnRzKS5qb2luKCdcIlxcblxcdFwiJykgKyAnXCJcXG4pXFxuXFxuJyArIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIFByb3RvIOexu+Wei+i9rCBHbyDnsbvlnotcbmZ1bmN0aW9uIHByb3RvVHlwZVRvR28odHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdHlwZU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnZG91YmxlJzogJ2Zsb2F0NjQnLFxuICAgICdmbG9hdCc6ICdmbG9hdDMyJyxcbiAgICAnaW50MzInOiAnaW50MzInLFxuICAgICdpbnQ2NCc6ICdpbnQ2NCcsXG4gICAgJ3VpbnQzMic6ICd1aW50MzInLFxuICAgICd1aW50NjQnOiAndWludDY0JyxcbiAgICAnc2ludDMyJzogJ2ludDMyJyxcbiAgICAnc2ludDY0JzogJ2ludDY0JyxcbiAgICAnZml4ZWQzMic6ICd1aW50MzInLFxuICAgICdmaXhlZDY0JzogJ3VpbnQ2NCcsXG4gICAgJ3NmaXhlZDMyJzogJ2ludDMyJyxcbiAgICAnc2ZpeGVkNjQnOiAnaW50NjQnLFxuICAgICdib29sJzogJ2Jvb2wnLFxuICAgICdzdHJpbmcnOiAnc3RyaW5nJyxcbiAgICAnYnl0ZXMnOiAnW11ieXRlJyxcbiAgICAnVGltZXN0YW1wJzogJ3RpbWUuVGltZSdcbiAgfTtcbiAgcmV0dXJuIHR5cGVNYXBbdHlwZV0gfHwgdHlwZTtcbn1cblxuLy8gWE1MIOi9rCBHbyDnu5PmnoTkvZNcbmZ1bmN0aW9uIHhtbFRvR28oeG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBjb25zdCBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgY29uc3Qgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgXG4gICAgcmV0dXJuIHByb2Nlc3NYTUxOb2RlKHJvb3QsIGNhcGl0YWxpemVGaXJzdChyb290LnRhZ05hbWUpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWE1MIOino+aekOmUmeivrycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NYTUxOb2RlKG5vZGU6IEVsZW1lbnQsIHN0cnVjdE5hbWU6IHN0cmluZywgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpKTogc3RyaW5nIHtcbiAgaWYgKHNlZW4uaGFzKHN0cnVjdE5hbWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHNlZW4uYWRkKHN0cnVjdE5hbWUpO1xuXG4gIGxldCBzdHJ1Y3QgPSBgdHlwZSAke3N0cnVjdE5hbWV9IHN0cnVjdCB7XFxuYDtcbiAgY29uc3QgbmVzdGVkU3RydWN0czogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZmllbGRzID0gbmV3IE1hcDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBpc0FycmF5OiBib29sZWFuIH0+KCk7XG5cbiAgLy8g5aSE55CG5a2Q5YWD57SgXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKSkge1xuICAgIGNvbnN0IGZpZWxkTmFtZSA9IGNhcGl0YWxpemVGaXJzdChjaGlsZC50YWdOYW1lKTtcbiAgICBjb25zdCBleGlzdGluZ0ZpZWxkID0gZmllbGRzLmdldChmaWVsZE5hbWUpO1xuXG4gICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkLmNoaWxkcmVuWzBdLm5vZGVUeXBlID09PSAzKSkge1xuICAgICAgLy8g566A5Y2V5YC8XG4gICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG4gICAgICBjb25zdCB0eXBlID0gaW5mZXJUeXBlRnJvbVZhbHVlKHZhbHVlKTtcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nRmllbGQpIHtcbiAgICAgICAgZXhpc3RpbmdGaWVsZC5pc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkcy5zZXQoZmllbGROYW1lLCB7IHR5cGUsIGlzQXJyYXk6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyDlpI3mnYLnsbvlnotcbiAgICAgIGNvbnN0IG5lc3RlZFN0cnVjdE5hbWUgPSBzdHJ1Y3ROYW1lICsgZmllbGROYW1lO1xuICAgICAgbmVzdGVkU3RydWN0cy5wdXNoKHByb2Nlc3NYTUxOb2RlKGNoaWxkLCBuZXN0ZWRTdHJ1Y3ROYW1lLCBzZWVuKSk7XG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0ZpZWxkKSB7XG4gICAgICAgIGV4aXN0aW5nRmllbGQuaXNBcnJheSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZHMuc2V0KGZpZWxkTmFtZSwgeyB0eXBlOiBuZXN0ZWRTdHJ1Y3ROYW1lLCBpc0FycmF5OiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyDnlJ/miJDlrZfmrrVcbiAgZm9yIChjb25zdCBbZmllbGROYW1lLCB7IHR5cGUsIGlzQXJyYXkgfV0gb2YgZmllbGRzKSB7XG4gICAgY29uc3QgZmllbGRUeXBlID0gaXNBcnJheSA/IGBbXSR7dHlwZX1gIDogdHlwZTtcbiAgICBzdHJ1Y3QgKz0gYFxcdCR7ZmllbGROYW1lfSAke2ZpZWxkVHlwZX0gXFxgeG1sOlwiJHtmaWVsZE5hbWUudG9Mb3dlckNhc2UoKX1cIiBqc29uOlwiJHtmaWVsZE5hbWUudG9Mb3dlckNhc2UoKX1cIlxcYFxcbmA7XG4gIH1cblxuICBzdHJ1Y3QgKz0gXCJ9XFxuXFxuXCI7XG4gIHJldHVybiBuZXN0ZWRTdHJ1Y3RzLmpvaW4oJycpICsgc3RydWN0O1xufVxuXG5mdW5jdGlvbiBpbmZlclR5cGVGcm9tVmFsdWUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSByZXR1cm4gJ2Jvb2wnO1xuICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHJldHVybiAnaW50JztcbiAgaWYgKC9eXFxkKlxcLlxcZCskLy50ZXN0KHZhbHVlKSkgcmV0dXJuICdmbG9hdDY0JztcbiAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0vLnRlc3QodmFsdWUpKSByZXR1cm4gJ3RpbWUuVGltZSc7XG4gIHJldHVybiAnc3RyaW5nJztcbn1cblxuLy8gQ1NWIOi9rCBHbyDnu5PmnoTkvZNcbmZ1bmN0aW9uIGNzdlRvR28oY3N2OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lcyA9IGNzdi5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTViDoh7PlsJHpnIDopoHljIXlkKvmoIfpopjooYzlkozkuIDooYzmlbDmja4nKTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdCgnLCcpLm1hcChoID0+IGgudHJpbSgpKTtcbiAgY29uc3QgZmlyc3RSb3cgPSBsaW5lc1sxXS5zcGxpdCgnLCcpLm1hcCh2ID0+IHYudHJpbSgpKTtcbiAgXG4gIGxldCBzdHJ1Y3QgPSBcInR5cGUgQXV0b0dlbiBzdHJ1Y3Qge1xcblwiO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gY2FwaXRhbGl6ZUZpcnN0KGhlYWRlcnNbaV0pO1xuICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3dbaV07XG4gICAgY29uc3QgdHlwZSA9IGluZmVyVHlwZUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgc3RydWN0ICs9IGBcXHQke2ZpZWxkTmFtZX0gJHt0eXBlfSBcXGBqc29uOlwiJHtoZWFkZXJzW2ldfVwiXFxgXFxuYDtcbiAgfVxuICBcbiAgc3RydWN0ICs9IFwifVxcblwiO1xuICByZXR1cm4gc3RydWN0O1xufVxuXG4vLyDlr7zlh7rmlrDnmoTovazmjaLlh73mlbBcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9HbyhpbnB1dDogc3RyaW5nLCB0eXBlOiAnanNvbicgfCAneWFtbCcgfCAnc3FsJyB8ICdwcm90bycgfCAneG1sJyB8ICdjc3YnLCBvcHRpb25zPzogU1FMT3B0aW9ucyk6IHN0cmluZyB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2pzb24nOlxuICAgICAgcmV0dXJuIGpzb25Ub0dvKEpTT04ucGFyc2UoaW5wdXQpLCAnQXV0b0dlbicpO1xuICAgIGNhc2UgJ3lhbWwnOlxuICAgICAgcmV0dXJuIGpzb25Ub0dvKFlBTUwucGFyc2UoaW5wdXQpLCAnQXV0b0dlbicpO1xuICAgIGNhc2UgJ3NxbCc6XG4gICAgICByZXR1cm4gc3FsVG9Hb1N0cnVjdChpbnB1dCwgb3B0aW9ucyEpO1xuICAgIGNhc2UgJ3Byb3RvJzpcbiAgICAgIHJldHVybiBwcm90b1RvR28oaW5wdXQpO1xuICAgIGNhc2UgJ3htbCc6XG4gICAgICByZXR1cm4geG1sVG9HbyhpbnB1dCk7XG4gICAgY2FzZSAnY3N2JzpcbiAgICAgIHJldHVybiBjc3ZUb0dvKGlucHV0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCfkuI3mlK/mjIHnmoTmoLzlvI/nsbvlnosnKTtcbiAgfVxufSAiXSwibmFtZXMiOlsiWUFNTCIsImluZmVyR29UeXBlIiwidmFsdWUiLCJzZWVuIiwiU2V0IiwidW5kZWZpbmVkIiwidHlwZSIsImlzUG9pbnRlciIsImlzQXJyYXkiLCJBcnJheSIsImxlbmd0aCIsImVsZW1lbnRUeXBlcyIsIm1hcCIsIml0ZW0iLCJpc1NhbWVUeXBlIiwiZXZlcnkiLCJ0IiwiZWxlbWVudFR5cGUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXMiLCJhZGQiLCJmb3JtYXRHb0ZpZWxkVHlwZSIsInJlc3VsdCIsImNhcGl0YWxpemVGaXJzdCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJqc29uVG9HbyIsIm9iaiIsInN0cnVjdE5hbWUiLCJuZXN0ZWRTdHJ1Y3RzIiwic3RydWN0Iiwia2V5IiwiT2JqZWN0IiwiZW50cmllcyIsImZpZWxkTmFtZSIsImdvVHlwZSIsIm5lc3RlZFN0cnVjdE5hbWUiLCJlbGVtZW50VmFsdWUiLCJwdXNoIiwiam9pbiIsImZvcm1hdEpTT04iLCJpbnB1dCIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImZvcm1hdFlBTUwiLCJpbmRlbnQiLCJzcWxUeXBlTWFwIiwibXlzcWwiLCJwb3N0Z3JlcyIsInNxbGl0ZSIsImdlbmVyYXRlVGFncyIsIm5hbWUiLCJzcWxUeXBlIiwib3B0aW9ucyIsInRhZ3MiLCJ0YWdUeXBlIiwiZ29ybVRhZ3MiLCJ4b3JtVGFncyIsInNxbFRvR29TdHJ1Y3QiLCJzcWwiLCJsaW5lcyIsInNwbGl0IiwiaGFzVGltZUltcG9ydCIsImhhc0RlY2ltYWxJbXBvcnQiLCJoYXNVVUlESW1wb3J0IiwibGluZSIsIm1hdGNoIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiZGJUeXBlIiwiZmllbGRUeXBlIiwidXNlUG9pbnRlciIsImltcG9ydHMiLCJTUUxfVEVNUExBVEUiLCJ2YWxpZGF0ZUZvcm1hdCIsImlzVmFsaWQiLCJlcnJvciIsInNxbExpbmVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiY3N2TGluZXMiLCJlIiwiRXJyb3IiLCJtZXNzYWdlIiwiVEVNUExBVEVTIiwianNvbiIsInlhbWwiLCJwcm90byIsInhtbCIsImNzdiIsInByb3RvVG9HbyIsIm91dHB1dCIsImN1cnJlbnRNZXNzYWdlIiwibWVzc2FnZU5hbWUiLCJmaWVsZE1hdGNoIiwicmVwZWF0ZWQiLCJwcm90b1R5cGVUb0dvIiwic2l6ZSIsImZyb20iLCJ0eXBlTWFwIiwieG1sVG9HbyIsInBhcnNlciIsImRvYyIsInJvb3QiLCJkb2N1bWVudEVsZW1lbnQiLCJwcm9jZXNzWE1MTm9kZSIsInRhZ05hbWUiLCJub2RlIiwiZmllbGRzIiwiTWFwIiwiY2hpbGQiLCJjaGlsZHJlbiIsImV4aXN0aW5nRmllbGQiLCJnZXQiLCJub2RlVHlwZSIsInRleHRDb250ZW50IiwiaW5mZXJUeXBlRnJvbVZhbHVlIiwic2V0IiwidGVzdCIsImNzdlRvR28iLCJoZWFkZXJzIiwiaCIsImZpcnN0Um93IiwidiIsImkiLCJjb252ZXJ0VG9HbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/utils.ts\n"));

/***/ })

});