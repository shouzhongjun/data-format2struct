"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./pages/utils.ts":
/*!************************!*\
  !*** ./pages/utils.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SQL_TEMPLATE: () => (/* binding */ SQL_TEMPLATE),\n/* harmony export */   formatJSON: () => (/* binding */ formatJSON),\n/* harmony export */   formatYAML: () => (/* binding */ formatYAML),\n/* harmony export */   jsonToGo: () => (/* binding */ jsonToGo),\n/* harmony export */   sqlToGoStruct: () => (/* binding */ sqlToGoStruct),\n/* harmony export */   validateFormat: () => (/* binding */ validateFormat)\n/* harmony export */ });\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ \"(pages-dir-browser)/./node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/index.js\");\n\nfunction inferGoType(value) {\n    let seen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set();\n    if (value === null || value === undefined) {\n        return {\n            type: \"interface{}\",\n            isPointer: true,\n            isArray: false\n        };\n    }\n    if (Array.isArray(value)) {\n        if (value.length === 0) {\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: true\n            };\n        }\n        // 分析数组中的所有元素类型\n        const elementTypes = value.map((item)=>inferGoType(item, seen));\n        // 如果所有元素类型相同，使用该类型；否则使用 interface{}\n        const isSameType = elementTypes.every((t)=>t.type === elementTypes[0].type && t.isPointer === elementTypes[0].isPointer);\n        return {\n            type: isSameType ? elementTypes[0].type : \"interface{}\",\n            isPointer: isSameType ? elementTypes[0].isPointer : false,\n            isArray: true,\n            elementType: isSameType ? elementTypes[0] : undefined\n        };\n    }\n    switch(typeof value){\n        case \"string\":\n            return {\n                type: \"string\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"number\":\n            if (Number.isInteger(value)) {\n                if (value > 2147483647 || value < -2147483648) {\n                    return {\n                        type: \"int64\",\n                        isPointer: false,\n                        isArray: false\n                    };\n                }\n                return {\n                    type: \"int\",\n                    isPointer: false,\n                    isArray: false\n                };\n            }\n            return {\n                type: \"float64\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"boolean\":\n            return {\n                type: \"bool\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"object\":\n            if (seen.has(value)) {\n                return {\n                    type: \"interface{}\",\n                    isPointer: true,\n                    isArray: false\n                };\n            }\n            seen.add(value);\n            return {\n                type: \"struct\",\n                isPointer: false,\n                isArray: false\n            };\n        default:\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: false\n            };\n    }\n}\nfunction formatGoFieldType(type) {\n    let result = \"\";\n    if (type.isArray) {\n        result += \"[]\";\n    }\n    if (type.isPointer) {\n        result += \"*\";\n    }\n    result += type.type;\n    return result;\n}\nfunction capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction jsonToGo(obj, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (typeof obj !== \"object\" || obj === null) {\n        return \"\";\n    }\n    if (seen.has(obj)) {\n        return \"\";\n    }\n    seen.add(obj);\n    const nestedStructs = [];\n    let struct = \"type \" + structName + \" struct {\\n\";\n    for (const [key, value] of Object.entries(obj)){\n        const fieldName = capitalizeFirst(key);\n        const goType = inferGoType(value, new Set(seen));\n        if (goType.type === \"struct\") {\n            const nestedStructName = structName + fieldName;\n            if (Array.isArray(value)) {\n                const elementValue = value[0];\n                if (elementValue && typeof elementValue === \"object\") {\n                    nestedStructs.push(jsonToGo(elementValue, nestedStructName, new Set(seen)));\n                    goType.type = nestedStructName;\n                }\n            } else {\n                nestedStructs.push(jsonToGo(value, nestedStructName, new Set(seen)));\n                goType.type = nestedStructName;\n            }\n        }\n        struct += \"\\t\" + fieldName + \" \" + formatGoFieldType(goType) + \" `json:\\\"\" + key + \"\\\"`\\n\";\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join(\"\") + struct;\n}\nfunction formatJSON(input) {\n    try {\n        const parsed = JSON.parse(input);\n        return JSON.stringify(parsed, null, 2);\n    } catch (e) {\n        return input;\n    }\n}\nfunction formatYAML(input) {\n    try {\n        const parsed = yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n        return yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stringify(parsed, {\n            indent: 2\n        });\n    } catch (e) {\n        return input;\n    }\n}\nconst sqlTypeMap = {\n    \"int\": {\n        mysql: \"int\",\n        postgres: \"int\",\n        sqlite: \"int\"\n    },\n    \"bigint\": {\n        mysql: \"int64\",\n        postgres: \"int64\",\n        sqlite: \"int64\"\n    },\n    \"tinyint\": {\n        mysql: \"int8\",\n        postgres: \"int8\",\n        sqlite: \"int8\"\n    },\n    \"smallint\": {\n        mysql: \"int16\",\n        postgres: \"int16\",\n        sqlite: \"int16\"\n    },\n    \"mediumint\": {\n        mysql: \"int32\",\n        postgres: \"int32\",\n        sqlite: \"int32\"\n    },\n    \"float\": {\n        mysql: \"float32\",\n        postgres: \"float32\",\n        sqlite: \"float32\"\n    },\n    \"double\": {\n        mysql: \"float64\",\n        postgres: \"float64\",\n        sqlite: \"float64\"\n    },\n    \"decimal\": {\n        mysql: \"float64\",\n        postgres: \"decimal.Decimal\",\n        sqlite: \"float64\"\n    },\n    \"varchar\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"char\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"text\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"mediumtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"longtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"datetime\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"timestamp\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"date\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"time\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"boolean\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"bool\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"json\": {\n        mysql: \"interface{}\",\n        postgres: \"interface{}\",\n        sqlite: \"interface{}\"\n    },\n    \"uuid\": {\n        mysql: \"string\",\n        postgres: \"uuid.UUID\",\n        sqlite: \"string\"\n    }\n};\nfunction generateTags(name, sqlType, options) {\n    const tags = [];\n    // 添加 json 标签\n    tags.push('json:\"'.concat(name, '\"'));\n    // 根据选择的标签类型添加对应的标签\n    switch(options.tagType){\n        case \"db\":\n            tags.push('db:\"'.concat(name, '\"'));\n            break;\n        case \"gorm\":\n            const gormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                gormTags.push(\"autoCreateTime\");\n            }\n            if (name === \"id\") {\n                gormTags.push(\"primaryKey\");\n            }\n            tags.push('gorm:\"'.concat(gormTags.join(';'), '\"'));\n            break;\n        case \"xorm\":\n            const xormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                xormTags.push(\"created\");\n            }\n            if (name === \"id\") {\n                xormTags.push(\"pk\");\n            }\n            tags.push('xorm:\"'.concat(xormTags.join(' '), '\"'));\n            break;\n    }\n    return tags.join(\" \");\n}\nfunction sqlToGoStruct(sql, options) {\n    const lines = sql.split(/\\r?\\n/);\n    let struct = \"type AutoGen struct {\\n\";\n    let hasTimeImport = false;\n    let hasDecimalImport = false;\n    let hasUUIDImport = false;\n    for (const line of lines){\n        const match = line.trim().match(/^([a-zA-Z0-9_]+)\\s+([a-zA-Z]+)(\\(\\d+\\))?/i);\n        if (match) {\n            var _sqlTypeMap_sqlType;\n            const [, name, type] = match;\n            const sqlType = type.toLowerCase();\n            const goType = ((_sqlTypeMap_sqlType = sqlTypeMap[sqlType]) === null || _sqlTypeMap_sqlType === void 0 ? void 0 : _sqlTypeMap_sqlType[options.dbType]) || \"interface{}\";\n            if (goType === \"time.Time\") {\n                hasTimeImport = true;\n            } else if (goType === \"decimal.Decimal\") {\n                hasDecimalImport = true;\n            } else if (goType === \"uuid.UUID\") {\n                hasUUIDImport = true;\n            }\n            const fieldName = capitalizeFirst(name);\n            const fieldType = options.usePointer && goType !== \"interface{}\" ? \"*\" + goType : goType;\n            const tags = generateTags(name, sqlType, options);\n            struct += \"\\t\" + fieldName + \" \" + fieldType + \" `\" + tags + \"`\\n\";\n        }\n    }\n    struct += \"}\\n\";\n    // 添加必要的导入\n    const imports = [];\n    if (hasTimeImport) {\n        imports.push('time');\n    }\n    if (hasDecimalImport) {\n        imports.push('github.com/shopspring/decimal');\n    }\n    if (hasUUIDImport) {\n        imports.push('github.com/google/uuid');\n    }\n    if (imports.length > 0) {\n        struct = 'import (\\n\\t\"' + imports.join('\"\\n\\t\"') + '\"\\n)\\n\\n' + struct;\n    }\n    return struct;\n}\nconst SQL_TEMPLATE = \"-- 用户表示例\\nid bigint\\nusername varchar(255)\\nemail varchar(255)\\npassword varchar(255)\\nage int\\ncreated_at datetime\\nupdated_at timestamp\\nis_active boolean\\nprofile_data json\\n\";\n// 添加格式校验函数\nfunction validateFormat(input, type) {\n    if (!input.trim()) {\n        return {\n            isValid: false,\n            error: \"输入内容为空\"\n        };\n    }\n    try {\n        switch(type){\n            case 'json':\n                JSON.parse(input);\n                return {\n                    isValid: true\n                };\n            case 'yaml':\n                yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n                return {\n                    isValid: true\n                };\n            case 'sql':\n                // 检查是否符合 SQL 字段定义格式\n                const lines = input.split(/\\r?\\n/).filter((line)=>line.trim() && !line.startsWith('--'));\n                if (lines.length === 0) {\n                    return {\n                        isValid: false,\n                        error: \"没有找到有效的 SQL 字段定义\"\n                    };\n                }\n                for (const line of lines){\n                    const match = line.trim().match(/^[a-zA-Z0-9_]+\\s+[a-zA-Z]+(\\(\\d+\\))?$/i);\n                    if (!match) {\n                        return {\n                            isValid: false,\n                            error: \"无效的 SQL 字段定义: \".concat(line)\n                        };\n                    }\n                }\n                return {\n                    isValid: true\n                };\n            default:\n                return {\n                    isValid: false,\n                    error: \"不支持的格式类型\"\n                };\n        }\n    } catch (e) {\n        return {\n            isValid: false,\n            error: \"格式错误: \".concat(e instanceof Error ? e.message : '未知错误')\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVLENBQUM0QztRQUMxQixPQUFPNUMsc0RBQWMsQ0FBQzZDLFFBQVE7WUFBRUssUUFBUTtRQUFFO0lBQzVDLEVBQUUsVUFBTTtRQUNOLE9BQU9OO0lBQ1Q7QUFDRjtBQUVBLE1BQU1PLGFBQXFEO0lBQ3pELE9BQU87UUFDTEMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFVBQVU7UUFDUkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFdBQVc7UUFDVEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFlBQVk7UUFDVkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLGFBQWE7UUFDWEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFNBQVM7UUFDUEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFVBQVU7UUFDUkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFdBQVc7UUFDVEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFdBQVc7UUFDVEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLGNBQWM7UUFDWkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFlBQVk7UUFDVkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFlBQVk7UUFDVkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLGFBQWE7UUFDWEYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkYsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkYsT0FB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RixFQUFFLE9BQU9HLEdBQUc7UUFDVixPQUFPO1lBQUVKLFNBQVM7WUFBT0MsT0FBTyxTQUFpRCxPQUF4Q0csYUFBYUMsUUFBUUQsRUFBRUUsT0FBTyxHQUFHO1FBQVM7SUFDckY7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3BpemF6ei9Eb3dubG9hZHMvanNvbi10by1nby12ZXJjZWwvcGFnZXMvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFlBTUwgZnJvbSAneWFtbCc7XG5pbXBvcnQgeyBTUUxPcHRpb25zLCBEQlR5cGUgfSBmcm9tICcuL3R5cGVzJztcblxuaW50ZXJmYWNlIEdvVHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgaXNQb2ludGVyOiBib29sZWFuO1xuICBpc0FycmF5OiBib29sZWFuO1xuICBlbGVtZW50VHlwZT86IEdvVHlwZTtcbn1cblxuZnVuY3Rpb24gaW5mZXJHb1R5cGUodmFsdWU6IGFueSwgc2VlbiA9IG5ldyBTZXQ8YW55PigpKTogR29UeXBlIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVyZmFjZXt9XCIsIGlzUG9pbnRlcjogdHJ1ZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogdHJ1ZSB9O1xuICAgIH1cbiAgICAvLyDliIbmnpDmlbDnu4TkuK3nmoTmiYDmnInlhYPntKDnsbvlnotcbiAgICBjb25zdCBlbGVtZW50VHlwZXMgPSB2YWx1ZS5tYXAoaXRlbSA9PiBpbmZlckdvVHlwZShpdGVtLCBzZWVuKSk7XG4gICAgLy8g5aaC5p6c5omA5pyJ5YWD57Sg57G75Z6L55u45ZCM77yM5L2/55So6K+l57G75Z6L77yb5ZCm5YiZ5L2/55SoIGludGVyZmFjZXt9XG4gICAgY29uc3QgaXNTYW1lVHlwZSA9IGVsZW1lbnRUeXBlcy5ldmVyeSh0ID0+IFxuICAgICAgdC50eXBlID09PSBlbGVtZW50VHlwZXNbMF0udHlwZSAmJiBcbiAgICAgIHQuaXNQb2ludGVyID09PSBlbGVtZW50VHlwZXNbMF0uaXNQb2ludGVyXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogaXNTYW1lVHlwZSA/IGVsZW1lbnRUeXBlc1swXS50eXBlIDogXCJpbnRlcmZhY2V7fVwiLFxuICAgICAgaXNQb2ludGVyOiBpc1NhbWVUeXBlID8gZWxlbWVudFR5cGVzWzBdLmlzUG9pbnRlciA6IGZhbHNlLFxuICAgICAgaXNBcnJheTogdHJ1ZSxcbiAgICAgIGVsZW1lbnRUeXBlOiBpc1NhbWVUeXBlID8gZWxlbWVudFR5cGVzWzBdIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJpbmdcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMjE0NzQ4MzY0NyB8fCB2YWx1ZSA8IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnQ2NFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcImZsb2F0NjRcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sXCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImludGVyZmFjZXt9XCIsIGlzUG9pbnRlcjogdHJ1ZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RydWN0XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRHb0ZpZWxkVHlwZSh0eXBlOiBHb1R5cGUpOiBzdHJpbmcge1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgaWYgKHR5cGUuaXNBcnJheSkge1xuICAgIHJlc3VsdCArPSBcIltdXCI7XG4gIH1cbiAgaWYgKHR5cGUuaXNQb2ludGVyKSB7XG4gICAgcmVzdWx0ICs9IFwiKlwiO1xuICB9XG4gIHJlc3VsdCArPSB0eXBlLnR5cGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqc29uVG9HbyhvYmo6IGFueSwgc3RydWN0TmFtZTogc3RyaW5nLCBzZWVuID0gbmV3IFNldDxhbnk+KCkpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGlmIChzZWVuLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgc2Vlbi5hZGQob2JqKTtcblxuICBjb25zdCBuZXN0ZWRTdHJ1Y3RzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgc3RydWN0ID0gXCJ0eXBlIFwiICsgc3RydWN0TmFtZSArIFwiIHN0cnVjdCB7XFxuXCI7XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGZpZWxkTmFtZSA9IGNhcGl0YWxpemVGaXJzdChrZXkpO1xuICAgIGNvbnN0IGdvVHlwZSA9IGluZmVyR29UeXBlKHZhbHVlLCBuZXcgU2V0KHNlZW4pKTtcblxuICAgIGlmIChnb1R5cGUudHlwZSA9PT0gXCJzdHJ1Y3RcIikge1xuICAgICAgY29uc3QgbmVzdGVkU3RydWN0TmFtZSA9IHN0cnVjdE5hbWUgKyBmaWVsZE5hbWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIGlmIChlbGVtZW50VmFsdWUgJiYgdHlwZW9mIGVsZW1lbnRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG5lc3RlZFN0cnVjdHMucHVzaChqc29uVG9HbyhlbGVtZW50VmFsdWUsIG5lc3RlZFN0cnVjdE5hbWUsIG5ldyBTZXQoc2VlbikpKTtcbiAgICAgICAgICBnb1R5cGUudHlwZSA9IG5lc3RlZFN0cnVjdE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lc3RlZFN0cnVjdHMucHVzaChqc29uVG9Hbyh2YWx1ZSwgbmVzdGVkU3RydWN0TmFtZSwgbmV3IFNldChzZWVuKSkpO1xuICAgICAgICBnb1R5cGUudHlwZSA9IG5lc3RlZFN0cnVjdE5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RydWN0ICs9IFwiXFx0XCIgKyBmaWVsZE5hbWUgKyBcIiBcIiArIGZvcm1hdEdvRmllbGRUeXBlKGdvVHlwZSkgKyBcIiBganNvbjpcXFwiXCIgKyBrZXkgKyBcIlxcXCJgXFxuXCI7XG4gIH1cblxuICBzdHJ1Y3QgKz0gXCJ9XFxuXFxuXCI7XG4gIHJldHVybiBuZXN0ZWRTdHJ1Y3RzLmpvaW4oXCJcIikgKyBzdHJ1Y3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRKU09OKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQsIG51bGwsIDIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFlBTUwoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gWUFNTC5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIFlBTUwuc3RyaW5naWZ5KHBhcnNlZCwgeyBpbmRlbnQ6IDIgfSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxufVxuXG5jb25zdCBzcWxUeXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8REJUeXBlLCBzdHJpbmc+PiA9IHtcbiAgXCJpbnRcIjoge1xuICAgIG15c3FsOiBcImludFwiLFxuICAgIHBvc3RncmVzOiBcImludFwiLFxuICAgIHNxbGl0ZTogXCJpbnRcIixcbiAgfSxcbiAgXCJiaWdpbnRcIjoge1xuICAgIG15c3FsOiBcImludDY0XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50NjRcIixcbiAgICBzcWxpdGU6IFwiaW50NjRcIixcbiAgfSxcbiAgXCJ0aW55aW50XCI6IHtcbiAgICBteXNxbDogXCJpbnQ4XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50OFwiLFxuICAgIHNxbGl0ZTogXCJpbnQ4XCIsXG4gIH0sXG4gIFwic21hbGxpbnRcIjoge1xuICAgIG15c3FsOiBcImludDE2XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50MTZcIixcbiAgICBzcWxpdGU6IFwiaW50MTZcIixcbiAgfSxcbiAgXCJtZWRpdW1pbnRcIjoge1xuICAgIG15c3FsOiBcImludDMyXCIsXG4gICAgcG9zdGdyZXM6IFwiaW50MzJcIixcbiAgICBzcWxpdGU6IFwiaW50MzJcIixcbiAgfSxcbiAgXCJmbG9hdFwiOiB7XG4gICAgbXlzcWw6IFwiZmxvYXQzMlwiLFxuICAgIHBvc3RncmVzOiBcImZsb2F0MzJcIixcbiAgICBzcWxpdGU6IFwiZmxvYXQzMlwiLFxuICB9LFxuICBcImRvdWJsZVwiOiB7XG4gICAgbXlzcWw6IFwiZmxvYXQ2NFwiLFxuICAgIHBvc3RncmVzOiBcImZsb2F0NjRcIixcbiAgICBzcWxpdGU6IFwiZmxvYXQ2NFwiLFxuICB9LFxuICBcImRlY2ltYWxcIjoge1xuICAgIG15c3FsOiBcImZsb2F0NjRcIixcbiAgICBwb3N0Z3JlczogXCJkZWNpbWFsLkRlY2ltYWxcIixcbiAgICBzcWxpdGU6IFwiZmxvYXQ2NFwiLFxuICB9LFxuICBcInZhcmNoYXJcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJjaGFyXCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwidGV4dFwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcIm1lZGl1bXRleHRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJsb25ndGV4dFwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcImRhdGV0aW1lXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gIH0sXG4gIFwidGltZXN0YW1wXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gIH0sXG4gIFwiZGF0ZVwiOiB7XG4gICAgbXlzcWw6IFwidGltZS5UaW1lXCIsXG4gICAgcG9zdGdyZXM6IFwidGltZS5UaW1lXCIsXG4gICAgc3FsaXRlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcInRpbWVcIjoge1xuICAgIG15c3FsOiBcInRpbWUuVGltZVwiLFxuICAgIHBvc3RncmVzOiBcInRpbWUuVGltZVwiLFxuICAgIHNxbGl0ZTogXCJ0aW1lLlRpbWVcIixcbiAgfSxcbiAgXCJib29sZWFuXCI6IHtcbiAgICBteXNxbDogXCJib29sXCIsXG4gICAgcG9zdGdyZXM6IFwiYm9vbFwiLFxuICAgIHNxbGl0ZTogXCJib29sXCIsXG4gIH0sXG4gIFwiYm9vbFwiOiB7XG4gICAgbXlzcWw6IFwiYm9vbFwiLFxuICAgIHBvc3RncmVzOiBcImJvb2xcIixcbiAgICBzcWxpdGU6IFwiYm9vbFwiLFxuICB9LFxuICBcImpzb25cIjoge1xuICAgIG15c3FsOiBcImludGVyZmFjZXt9XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50ZXJmYWNle31cIixcbiAgICBzcWxpdGU6IFwiaW50ZXJmYWNle31cIixcbiAgfSxcbiAgXCJ1dWlkXCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJ1dWlkLlVVSURcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhZ3MobmFtZTogc3RyaW5nLCBzcWxUeXBlOiBzdHJpbmcsIG9wdGlvbnM6IFNRTE9wdGlvbnMpOiBzdHJpbmcge1xuICBjb25zdCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIOa3u+WKoCBqc29uIOagh+etvlxuICB0YWdzLnB1c2goYGpzb246XCIke25hbWV9XCJgKTtcblxuICAvLyDmoLnmja7pgInmi6nnmoTmoIfnrb7nsbvlnovmt7vliqDlr7nlupTnmoTmoIfnrb5cbiAgc3dpdGNoIChvcHRpb25zLnRhZ1R5cGUpIHtcbiAgICBjYXNlIFwiZGJcIjpcbiAgICAgIHRhZ3MucHVzaChgZGI6XCIke25hbWV9XCJgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJnb3JtXCI6XG4gICAgICBjb25zdCBnb3JtVGFnczogc3RyaW5nW10gPSBbbmFtZV07XG4gICAgICBpZiAoc3FsVHlwZSA9PT0gXCJkYXRldGltZVwiIHx8IHNxbFR5cGUgPT09IFwidGltZXN0YW1wXCIpIHtcbiAgICAgICAgZ29ybVRhZ3MucHVzaChcImF1dG9DcmVhdGVUaW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwiaWRcIikge1xuICAgICAgICBnb3JtVGFncy5wdXNoKFwicHJpbWFyeUtleVwiKTtcbiAgICAgIH1cbiAgICAgIHRhZ3MucHVzaChgZ29ybTpcIiR7Z29ybVRhZ3Muam9pbignOycpfVwiYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieG9ybVwiOlxuICAgICAgY29uc3QgeG9ybVRhZ3M6IHN0cmluZ1tdID0gW25hbWVdO1xuICAgICAgaWYgKHNxbFR5cGUgPT09IFwiZGF0ZXRpbWVcIiB8fCBzcWxUeXBlID09PSBcInRpbWVzdGFtcFwiKSB7XG4gICAgICAgIHhvcm1UYWdzLnB1c2goXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwiaWRcIikge1xuICAgICAgICB4b3JtVGFncy5wdXNoKFwicGtcIik7XG4gICAgICB9XG4gICAgICB0YWdzLnB1c2goYHhvcm06XCIke3hvcm1UYWdzLmpvaW4oJyAnKX1cImApO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGFncy5qb2luKFwiIFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxbFRvR29TdHJ1Y3Qoc3FsOiBzdHJpbmcsIG9wdGlvbnM6IFNRTE9wdGlvbnMpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lcyA9IHNxbC5zcGxpdCgvXFxyP1xcbi8pO1xuICBsZXQgc3RydWN0ID0gXCJ0eXBlIEF1dG9HZW4gc3RydWN0IHtcXG5cIjtcbiAgbGV0IGhhc1RpbWVJbXBvcnQgPSBmYWxzZTtcbiAgbGV0IGhhc0RlY2ltYWxJbXBvcnQgPSBmYWxzZTtcbiAgbGV0IGhhc1VVSURJbXBvcnQgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUudHJpbSgpLm1hdGNoKC9eKFthLXpBLVowLTlfXSspXFxzKyhbYS16QS1aXSspKFxcKFxcZCtcXCkpPy9pKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIG5hbWUsIHR5cGVdID0gbWF0Y2g7XG4gICAgICBjb25zdCBzcWxUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgZ29UeXBlID0gc3FsVHlwZU1hcFtzcWxUeXBlXT8uW29wdGlvbnMuZGJUeXBlXSB8fCBcImludGVyZmFjZXt9XCI7XG5cbiAgICAgIGlmIChnb1R5cGUgPT09IFwidGltZS5UaW1lXCIpIHtcbiAgICAgICAgaGFzVGltZUltcG9ydCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdvVHlwZSA9PT0gXCJkZWNpbWFsLkRlY2ltYWxcIikge1xuICAgICAgICBoYXNEZWNpbWFsSW1wb3J0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ29UeXBlID09PSBcInV1aWQuVVVJRFwiKSB7XG4gICAgICAgIGhhc1VVSURJbXBvcnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBjYXBpdGFsaXplRmlyc3QobmFtZSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBvcHRpb25zLnVzZVBvaW50ZXIgJiYgZ29UeXBlICE9PSBcImludGVyZmFjZXt9XCIgPyBcIipcIiArIGdvVHlwZSA6IGdvVHlwZTtcbiAgICAgIGNvbnN0IHRhZ3MgPSBnZW5lcmF0ZVRhZ3MobmFtZSwgc3FsVHlwZSwgb3B0aW9ucyk7XG4gICAgICBzdHJ1Y3QgKz0gXCJcXHRcIiArIGZpZWxkTmFtZSArIFwiIFwiICsgZmllbGRUeXBlICsgXCIgYFwiICsgdGFncyArIFwiYFxcblwiO1xuICAgIH1cbiAgfVxuXG4gIHN0cnVjdCArPSBcIn1cXG5cIjtcblxuICAvLyDmt7vliqDlv4XopoHnmoTlr7zlhaVcbiAgY29uc3QgaW1wb3J0czogc3RyaW5nW10gPSBbXTtcbiAgaWYgKGhhc1RpbWVJbXBvcnQpIHtcbiAgICBpbXBvcnRzLnB1c2goJ3RpbWUnKTtcbiAgfVxuICBpZiAoaGFzRGVjaW1hbEltcG9ydCkge1xuICAgIGltcG9ydHMucHVzaCgnZ2l0aHViLmNvbS9zaG9wc3ByaW5nL2RlY2ltYWwnKTtcbiAgfVxuICBpZiAoaGFzVVVJREltcG9ydCkge1xuICAgIGltcG9ydHMucHVzaCgnZ2l0aHViLmNvbS9nb29nbGUvdXVpZCcpO1xuICB9XG5cbiAgaWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgIHN0cnVjdCA9ICdpbXBvcnQgKFxcblxcdFwiJyArIGltcG9ydHMuam9pbignXCJcXG5cXHRcIicpICsgJ1wiXFxuKVxcblxcbicgKyBzdHJ1Y3Q7XG4gIH1cblxuICByZXR1cm4gc3RydWN0O1xufVxuXG5leHBvcnQgY29uc3QgU1FMX1RFTVBMQVRFID0gYC0tIOeUqOaIt+ihqOekuuS+i1xuaWQgYmlnaW50XG51c2VybmFtZSB2YXJjaGFyKDI1NSlcbmVtYWlsIHZhcmNoYXIoMjU1KVxucGFzc3dvcmQgdmFyY2hhcigyNTUpXG5hZ2UgaW50XG5jcmVhdGVkX2F0IGRhdGV0aW1lXG51cGRhdGVkX2F0IHRpbWVzdGFtcFxuaXNfYWN0aXZlIGJvb2xlYW5cbnByb2ZpbGVfZGF0YSBqc29uXG5gO1xuXG4vLyDmt7vliqDmoLzlvI/moKHpqozlh73mlbBcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChpbnB1dDogc3RyaW5nLCB0eXBlOiAnanNvbicgfCAneWFtbCcgfCAnc3FsJyk6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIGlmICghaW5wdXQudHJpbSgpKSB7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIui+k+WFpeWGheWuueS4uuepulwiIH07XG4gIH1cblxuICB0cnkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gICAgICBjYXNlICd5YW1sJzpcbiAgICAgICAgWUFNTC5wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGNhc2UgJ3NxbCc6XG4gICAgICAgIC8vIOajgOafpeaYr+WQpuespuWQiCBTUUwg5a2X5q615a6a5LmJ5qC85byPXG4gICAgICAgIGNvbnN0IGxpbmVzID0gaW5wdXQuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAmJiAhbGluZS5zdGFydHNXaXRoKCctLScpKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCLmsqHmnInmib7liLDmnInmlYjnmoQgU1FMIOWtl+auteWumuS5iVwiIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLnRyaW0oKS5tYXRjaCgvXlthLXpBLVowLTlfXStcXHMrW2EtekEtWl0rKFxcKFxcZCtcXCkpPyQvaSk7XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBg5peg5pWI55qEIFNRTCDlrZfmrrXlrprkuYk6ICR7bGluZX1gIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCLkuI3mlK/mjIHnmoTmoLzlvI/nsbvlnotcIiB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogYOagvOW8j+mUmeivrzogJHtlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAn5pyq55+l6ZSZ6K+vJ31gIH07XG4gIH1cbn0gIl0sIm5hbWVzIjpbIllBTUwiLCJpbmZlckdvVHlwZSIsInZhbHVlIiwic2VlbiIsIlNldCIsInVuZGVmaW5lZCIsInR5cGUiLCJpc1BvaW50ZXIiLCJpc0FycmF5IiwiQXJyYXkiLCJsZW5ndGgiLCJlbGVtZW50VHlwZXMiLCJtYXAiLCJpdGVtIiwiaXNTYW1lVHlwZSIsImV2ZXJ5IiwidCIsImVsZW1lbnRUeXBlIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaGFzIiwiYWRkIiwiZm9ybWF0R29GaWVsZFR5cGUiLCJyZXN1bHQiLCJjYXBpdGFsaXplRmlyc3QiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwianNvblRvR28iLCJvYmoiLCJzdHJ1Y3ROYW1lIiwibmVzdGVkU3RydWN0cyIsInN0cnVjdCIsImtleSIsIk9iamVjdCIsImVudHJpZXMiLCJmaWVsZE5hbWUiLCJnb1R5cGUiLCJuZXN0ZWRTdHJ1Y3ROYW1lIiwiZWxlbWVudFZhbHVlIiwicHVzaCIsImpvaW4iLCJmb3JtYXRKU09OIiwiaW5wdXQiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJmb3JtYXRZQU1MIiwiaW5kZW50Iiwic3FsVHlwZU1hcCIsIm15c3FsIiwicG9zdGdyZXMiLCJzcWxpdGUiLCJnZW5lcmF0ZVRhZ3MiLCJuYW1lIiwic3FsVHlwZSIsIm9wdGlvbnMiLCJ0YWdzIiwidGFnVHlwZSIsImdvcm1UYWdzIiwieG9ybVRhZ3MiLCJzcWxUb0dvU3RydWN0Iiwic3FsIiwibGluZXMiLCJzcGxpdCIsImhhc1RpbWVJbXBvcnQiLCJoYXNEZWNpbWFsSW1wb3J0IiwiaGFzVVVJREltcG9ydCIsImxpbmUiLCJtYXRjaCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImRiVHlwZSIsImZpZWxkVHlwZSIsInVzZVBvaW50ZXIiLCJpbXBvcnRzIiwiU1FMX1RFTVBMQVRFIiwidmFsaWRhdGVGb3JtYXQiLCJpc1ZhbGlkIiwiZXJyb3IiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiZSIsIkVycm9yIiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/utils.ts\n"));

/***/ })

});