"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./pages/utils.ts":
/*!************************!*\
  !*** ./pages/utils.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SQL_TEMPLATE: () => (/* binding */ SQL_TEMPLATE),\n/* harmony export */   formatJSON: () => (/* binding */ formatJSON),\n/* harmony export */   formatYAML: () => (/* binding */ formatYAML),\n/* harmony export */   jsonToGo: () => (/* binding */ jsonToGo),\n/* harmony export */   sqlToGoStruct: () => (/* binding */ sqlToGoStruct)\n/* harmony export */ });\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ \"(pages-dir-browser)/./node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/index.js\");\n\nfunction inferGoType(value) {\n    let seen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set();\n    if (value === null || value === undefined) {\n        return {\n            type: \"interface{}\",\n            isPointer: true,\n            isArray: false\n        };\n    }\n    if (Array.isArray(value)) {\n        if (value.length === 0) {\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: true\n            };\n        }\n        // 分析数组中的所有元素类型\n        const elementTypes = value.map((item)=>inferGoType(item, seen));\n        // 如果所有元素类型相同，使用该类型；否则使用 interface{}\n        const isSameType = elementTypes.every((t)=>t.type === elementTypes[0].type && t.isPointer === elementTypes[0].isPointer);\n        return {\n            type: isSameType ? elementTypes[0].type : \"interface{}\",\n            isPointer: isSameType ? elementTypes[0].isPointer : false,\n            isArray: true,\n            elementType: isSameType ? elementTypes[0] : undefined\n        };\n    }\n    switch(typeof value){\n        case \"string\":\n            return {\n                type: \"string\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"number\":\n            if (Number.isInteger(value)) {\n                if (value > 2147483647 || value < -2147483648) {\n                    return {\n                        type: \"int64\",\n                        isPointer: false,\n                        isArray: false\n                    };\n                }\n                return {\n                    type: \"int\",\n                    isPointer: false,\n                    isArray: false\n                };\n            }\n            return {\n                type: \"float64\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"boolean\":\n            return {\n                type: \"bool\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"object\":\n            if (seen.has(value)) {\n                return {\n                    type: \"interface{}\",\n                    isPointer: true,\n                    isArray: false\n                };\n            }\n            seen.add(value);\n            return {\n                type: \"struct\",\n                isPointer: false,\n                isArray: false\n            };\n        default:\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: false\n            };\n    }\n}\nfunction formatGoFieldType(type) {\n    let result = \"\";\n    if (type.isArray) {\n        result += \"[]\";\n    }\n    if (type.isPointer) {\n        result += \"*\";\n    }\n    result += type.type;\n    return result;\n}\nfunction capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction jsonToGo(obj, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (typeof obj !== \"object\" || obj === null) {\n        return \"\";\n    }\n    if (seen.has(obj)) {\n        return \"\";\n    }\n    seen.add(obj);\n    const nestedStructs = [];\n    let struct = \"type \" + structName + \" struct {\\n\";\n    for (const [key, value] of Object.entries(obj)){\n        const fieldName = capitalizeFirst(key);\n        const goType = inferGoType(value, new Set(seen));\n        if (goType.type === \"struct\") {\n            const nestedStructName = structName + fieldName;\n            if (Array.isArray(value)) {\n                const elementValue = value[0];\n                if (elementValue && typeof elementValue === \"object\") {\n                    nestedStructs.push(jsonToGo(elementValue, nestedStructName, new Set(seen)));\n                    goType.type = nestedStructName;\n                }\n            } else {\n                nestedStructs.push(jsonToGo(value, nestedStructName, new Set(seen)));\n                goType.type = nestedStructName;\n            }\n        }\n        struct += \"\\t\" + fieldName + \" \" + formatGoFieldType(goType) + \" `json:\\\"\" + key + \"\\\"`\\n\";\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join(\"\") + struct;\n}\nfunction formatJSON(input) {\n    try {\n        const parsed = JSON.parse(input);\n        return JSON.stringify(parsed, null, 2);\n    } catch (e) {\n        return input;\n    }\n}\nfunction formatYAML(input) {\n    try {\n        const parsed = yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n        return yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stringify(parsed, {\n            indent: 2\n        });\n    } catch (e) {\n        return input;\n    }\n}\nconst sqlTypeMap = {\n    \"int\": {\n        mysql: \"int\",\n        postgres: \"int\",\n        sqlite: \"int\"\n    },\n    \"bigint\": {\n        mysql: \"int64\",\n        postgres: \"int64\",\n        sqlite: \"int64\"\n    },\n    \"tinyint\": {\n        mysql: \"int8\",\n        postgres: \"int8\",\n        sqlite: \"int8\"\n    },\n    \"smallint\": {\n        mysql: \"int16\",\n        postgres: \"int16\",\n        sqlite: \"int16\"\n    },\n    \"mediumint\": {\n        mysql: \"int32\",\n        postgres: \"int32\",\n        sqlite: \"int32\"\n    },\n    \"float\": {\n        mysql: \"float32\",\n        postgres: \"float32\",\n        sqlite: \"float32\"\n    },\n    \"double\": {\n        mysql: \"float64\",\n        postgres: \"float64\",\n        sqlite: \"float64\"\n    },\n    \"decimal\": {\n        mysql: \"float64\",\n        postgres: \"decimal.Decimal\",\n        sqlite: \"float64\"\n    },\n    \"varchar\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"char\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"text\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"mediumtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"longtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\"\n    },\n    \"datetime\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"timestamp\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"date\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"time\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\"\n    },\n    \"boolean\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"bool\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\"\n    },\n    \"json\": {\n        mysql: \"interface{}\",\n        postgres: \"interface{}\",\n        sqlite: \"interface{}\"\n    },\n    \"uuid\": {\n        mysql: \"string\",\n        postgres: \"uuid.UUID\",\n        sqlite: \"string\"\n    }\n};\nfunction generateTags(name, sqlType, options) {\n    const tags = [];\n    // 添加 json 标签\n    tags.push('json:\"'.concat(name, '\"'));\n    // 根据选择的标签类型添加对应的标签\n    switch(options.tagType){\n        case \"db\":\n            tags.push('db:\"'.concat(name, '\"'));\n            break;\n        case \"gorm\":\n            const gormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                gormTags.push(\"autoCreateTime\");\n            }\n            if (name === \"id\") {\n                gormTags.push(\"primaryKey\");\n            }\n            tags.push('gorm:\"'.concat(gormTags.join(';'), '\"'));\n            break;\n        case \"xorm\":\n            const xormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                xormTags.push(\"created\");\n            }\n            if (name === \"id\") {\n                xormTags.push(\"pk\");\n            }\n            tags.push('xorm:\"'.concat(xormTags.join(' '), '\"'));\n            break;\n    }\n    return tags.join(\" \");\n}\nfunction sqlToGoStruct(sql, options) {\n    const lines = sql.split(/\\r?\\n/);\n    let struct = \"type AutoGen struct {\\n\";\n    let hasTimeImport = false;\n    let hasDecimalImport = false;\n    let hasUUIDImport = false;\n    for (const line of lines){\n        const match = line.trim().match(/^([a-zA-Z0-9_]+)\\s+([a-zA-Z]+)(\\(\\d+\\))?/i);\n        if (match) {\n            var _sqlTypeMap_sqlType;\n            const [, name, type] = match;\n            const sqlType = type.toLowerCase();\n            const goType = ((_sqlTypeMap_sqlType = sqlTypeMap[sqlType]) === null || _sqlTypeMap_sqlType === void 0 ? void 0 : _sqlTypeMap_sqlType[options.dbType]) || \"interface{}\";\n            if (goType === \"time.Time\") {\n                hasTimeImport = true;\n            } else if (goType === \"decimal.Decimal\") {\n                hasDecimalImport = true;\n            } else if (goType === \"uuid.UUID\") {\n                hasUUIDImport = true;\n            }\n            const fieldName = capitalizeFirst(name);\n            const fieldType = options.usePointer && goType !== \"interface{}\" ? \"*\" + goType : goType;\n            const tags = generateTags(name, sqlType, options);\n            struct += \"\\t\" + fieldName + \" \" + fieldType + \" `\" + tags + \"`\\n\";\n        }\n    }\n    struct += \"}\\n\";\n    // 添加必要的导入\n    const imports = [];\n    if (hasTimeImport) {\n        imports.push('time');\n    }\n    if (hasDecimalImport) {\n        imports.push('github.com/shopspring/decimal');\n    }\n    if (hasUUIDImport) {\n        imports.push('github.com/google/uuid');\n    }\n    if (imports.length > 0) {\n        struct = 'import (\\n\\t\"' + imports.join('\"\\n\\t\"') + '\"\\n)\\n\\n' + struct;\n    }\n    return struct;\n}\nconst SQL_TEMPLATE = \"-- 用户表示例\\nid bigint\\nusername varchar(255)\\nemail varchar(255)\\npassword varchar(255)\\nage int\\ncreated_at datetime\\nupdated_at timestamp\\nis_active boolean\\nprofile_data json\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVUsQ0FBQzRDO1FBQzFCLE9BQU81QyxzREFBYyxDQUFDNkMsUUFBUTtZQUFFSyxRQUFRO1FBQUU7SUFDNUMsRUFBRSxVQUFNO1FBQ04sT0FBT047SUFDVDtBQUNGO0FBRUEsTUFBTU8sYUFBcUQ7SUFDekQsT0FBTztRQUNMQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsVUFBVTtRQUNSRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsYUFBYTtRQUNYRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsU0FBUztRQUNQRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsVUFBVTtRQUNSRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNURixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsY0FBYztRQUNaRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsYUFBYTtRQUNYRixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNORixPQUFP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UUFDakJRLFFBQVFwQyxJQUFJLENBQUM7SUFDZjtJQUVBLElBQUlvQyxRQUFRbkUsTUFBTSxHQUFHLEdBQUc7UUFDdEJ1QixTQUFTLGtCQUFrQjRDLFFBQVFuQyxJQUFJLENBQUMsWUFBWSxhQUFhVDtJQUNuRTtJQUVBLE9BQU9BO0FBQ1Q7QUFFTyxNQUFNNkMsZUFBZ0Isb0xBVTNCIiwic291cmNlcyI6WyIvVXNlcnMvcGl6YXp6L0Rvd25sb2Fkcy9qc29uLXRvLWdvLXZlcmNlbC9wYWdlcy91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWUFNTCBmcm9tICd5YW1sJztcbmltcG9ydCB7IFNRTE9wdGlvbnMsIERCVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgR29UeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBpc1BvaW50ZXI6IGJvb2xlYW47XG4gIGlzQXJyYXk6IGJvb2xlYW47XG4gIGVsZW1lbnRUeXBlPzogR29UeXBlO1xufVxuXG5mdW5jdGlvbiBpbmZlckdvVHlwZSh2YWx1ZTogYW55LCBzZWVuID0gbmV3IFNldDxhbnk+KCkpOiBHb1R5cGUge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiB0cnVlLCBpc0FycmF5OiBmYWxzZSB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiB0cnVlIH07XG4gICAgfVxuICAgIC8vIOWIhuaekOaVsOe7hOS4reeahOaJgOacieWFg+e0oOexu+Wei1xuICAgIGNvbnN0IGVsZW1lbnRUeXBlcyA9IHZhbHVlLm1hcChpdGVtID0+IGluZmVyR29UeXBlKGl0ZW0sIHNlZW4pKTtcbiAgICAvLyDlpoLmnpzmiYDmnInlhYPntKDnsbvlnovnm7jlkIzvvIzkvb/nlKjor6XnsbvlnovvvJvlkKbliJnkvb/nlKggaW50ZXJmYWNle31cbiAgICBjb25zdCBpc1NhbWVUeXBlID0gZWxlbWVudFR5cGVzLmV2ZXJ5KHQgPT4gXG4gICAgICB0LnR5cGUgPT09IGVsZW1lbnRUeXBlc1swXS50eXBlICYmIFxuICAgICAgdC5pc1BvaW50ZXIgPT09IGVsZW1lbnRUeXBlc1swXS5pc1BvaW50ZXJcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBpc1NhbWVUeXBlID8gZWxlbWVudFR5cGVzWzBdLnR5cGUgOiBcImludGVyZmFjZXt9XCIsXG4gICAgICBpc1BvaW50ZXI6IGlzU2FtZVR5cGUgPyBlbGVtZW50VHlwZXNbMF0uaXNQb2ludGVyIDogZmFsc2UsXG4gICAgICBpc0FycmF5OiB0cnVlLFxuICAgICAgZWxlbWVudFR5cGU6IGlzU2FtZVR5cGUgPyBlbGVtZW50VHlwZXNbMF0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgPiAyMTQ3NDgzNjQ3IHx8IHZhbHVlIDwgLTIxNDc0ODM2NDgpIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImludDY0XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZmxvYXQ2NFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImJvb2xcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiB0cnVlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJ1Y3RcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEdvRmllbGRUeXBlKHR5cGU6IEdvVHlwZSk6IHN0cmluZyB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBpZiAodHlwZS5pc0FycmF5KSB7XG4gICAgcmVzdWx0ICs9IFwiW11cIjtcbiAgfVxuICBpZiAodHlwZS5pc1BvaW50ZXIpIHtcbiAgICByZXN1bHQgKz0gXCIqXCI7XG4gIH1cbiAgcmVzdWx0ICs9IHR5cGUudHlwZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpzb25Ub0dvKG9iajogYW55LCBzdHJ1Y3ROYW1lOiBzdHJpbmcsIHNlZW4gPSBuZXcgU2V0PGFueT4oKSk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgaWYgKHNlZW4uaGFzKG9iaikpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBzZWVuLmFkZChvYmopO1xuXG4gIGNvbnN0IG5lc3RlZFN0cnVjdHM6IHN0cmluZ1tdID0gW107XG4gIGxldCBzdHJ1Y3QgPSBcInR5cGUgXCIgKyBzdHJ1Y3ROYW1lICsgXCIgc3RydWN0IHtcXG5cIjtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gY2FwaXRhbGl6ZUZpcnN0KGtleSk7XG4gICAgY29uc3QgZ29UeXBlID0gaW5mZXJHb1R5cGUodmFsdWUsIG5ldyBTZXQoc2VlbikpO1xuXG4gICAgaWYgKGdvVHlwZS50eXBlID09PSBcInN0cnVjdFwiKSB7XG4gICAgICBjb25zdCBuZXN0ZWRTdHJ1Y3ROYW1lID0gc3RydWN0TmFtZSArIGZpZWxkTmFtZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZSAmJiB0eXBlb2YgZWxlbWVudFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmVzdGVkU3RydWN0cy5wdXNoKGpzb25Ub0dvKGVsZW1lbnRWYWx1ZSwgbmVzdGVkU3RydWN0TmFtZSwgbmV3IFNldChzZWVuKSkpO1xuICAgICAgICAgIGdvVHlwZS50eXBlID0gbmVzdGVkU3RydWN0TmFtZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVzdGVkU3RydWN0cy5wdXNoKGpzb25Ub0dvKHZhbHVlLCBuZXN0ZWRTdHJ1Y3ROYW1lLCBuZXcgU2V0KHNlZW4pKSk7XG4gICAgICAgIGdvVHlwZS50eXBlID0gbmVzdGVkU3RydWN0TmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJ1Y3QgKz0gXCJcXHRcIiArIGZpZWxkTmFtZSArIFwiIFwiICsgZm9ybWF0R29GaWVsZFR5cGUoZ29UeXBlKSArIFwiIGBqc29uOlxcXCJcIiArIGtleSArIFwiXFxcImBcXG5cIjtcbiAgfVxuXG4gIHN0cnVjdCArPSBcIn1cXG5cXG5cIjtcbiAgcmV0dXJuIG5lc3RlZFN0cnVjdHMuam9pbihcIlwiKSArIHN0cnVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEpTT04oaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZCwgbnVsbCwgMik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0WUFNTChpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBZQU1MLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gWUFNTC5zdHJpbmdpZnkocGFyc2VkLCB7IGluZGVudDogMiB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59XG5cbmNvbnN0IHNxbFR5cGVNYXA6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxEQlR5cGUsIHN0cmluZz4+ID0ge1xuICBcImludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50XCIsXG4gICAgc3FsaXRlOiBcImludFwiLFxuICB9LFxuICBcImJpZ2ludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50NjRcIixcbiAgICBwb3N0Z3JlczogXCJpbnQ2NFwiLFxuICAgIHNxbGl0ZTogXCJpbnQ2NFwiLFxuICB9LFxuICBcInRpbnlpbnRcIjoge1xuICAgIG15c3FsOiBcImludDhcIixcbiAgICBwb3N0Z3JlczogXCJpbnQ4XCIsXG4gICAgc3FsaXRlOiBcImludDhcIixcbiAgfSxcbiAgXCJzbWFsbGludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50MTZcIixcbiAgICBwb3N0Z3JlczogXCJpbnQxNlwiLFxuICAgIHNxbGl0ZTogXCJpbnQxNlwiLFxuICB9LFxuICBcIm1lZGl1bWludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50MzJcIixcbiAgICBwb3N0Z3JlczogXCJpbnQzMlwiLFxuICAgIHNxbGl0ZTogXCJpbnQzMlwiLFxuICB9LFxuICBcImZsb2F0XCI6IHtcbiAgICBteXNxbDogXCJmbG9hdDMyXCIsXG4gICAgcG9zdGdyZXM6IFwiZmxvYXQzMlwiLFxuICAgIHNxbGl0ZTogXCJmbG9hdDMyXCIsXG4gIH0sXG4gIFwiZG91YmxlXCI6IHtcbiAgICBteXNxbDogXCJmbG9hdDY0XCIsXG4gICAgcG9zdGdyZXM6IFwiZmxvYXQ2NFwiLFxuICAgIHNxbGl0ZTogXCJmbG9hdDY0XCIsXG4gIH0sXG4gIFwiZGVjaW1hbFwiOiB7XG4gICAgbXlzcWw6IFwiZmxvYXQ2NFwiLFxuICAgIHBvc3RncmVzOiBcImRlY2ltYWwuRGVjaW1hbFwiLFxuICAgIHNxbGl0ZTogXCJmbG9hdDY0XCIsXG4gIH0sXG4gIFwidmFyY2hhclwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcImNoYXJcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJ0ZXh0XCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwibWVkaXVtdGV4dFwiOiB7XG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcImxvbmd0ZXh0XCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwiZGF0ZXRpbWVcIjoge1xuICAgIG15c3FsOiBcInRpbWUuVGltZVwiLFxuICAgIHBvc3RncmVzOiBcInRpbWUuVGltZVwiLFxuICAgIHNxbGl0ZTogXCJ0aW1lLlRpbWVcIixcbiAgfSxcbiAgXCJ0aW1lc3RhbXBcIjoge1xuICAgIG15c3FsOiBcInRpbWUuVGltZVwiLFxuICAgIHBvc3RncmVzOiBcInRpbWUuVGltZVwiLFxuICAgIHNxbGl0ZTogXCJ0aW1lLlRpbWVcIixcbiAgfSxcbiAgXCJkYXRlXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gIH0sXG4gIFwidGltZVwiOiB7XG4gICAgbXlzcWw6IFwidGltZS5UaW1lXCIsXG4gICAgcG9zdGdyZXM6IFwidGltZS5UaW1lXCIsXG4gICAgc3FsaXRlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcImJvb2xlYW5cIjoge1xuICAgIG15c3FsOiBcImJvb2xcIixcbiAgICBwb3N0Z3JlczogXCJib29sXCIsXG4gICAgc3FsaXRlOiBcImJvb2xcIixcbiAgfSxcbiAgXCJib29sXCI6IHtcbiAgICBteXNxbDogXCJib29sXCIsXG4gICAgcG9zdGdyZXM6IFwiYm9vbFwiLFxuICAgIHNxbGl0ZTogXCJib29sXCIsXG4gIH0sXG4gIFwianNvblwiOiB7XG4gICAgbXlzcWw6IFwiaW50ZXJmYWNle31cIixcbiAgICBwb3N0Z3JlczogXCJpbnRlcmZhY2V7fVwiLFxuICAgIHNxbGl0ZTogXCJpbnRlcmZhY2V7fVwiLFxuICB9LFxuICBcInV1aWRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInV1aWQuVVVJRFwiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGFncyhuYW1lOiBzdHJpbmcsIHNxbFR5cGU6IHN0cmluZywgb3B0aW9uczogU1FMT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHRhZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgLy8g5re75YqgIGpzb24g5qCH562+XG4gIHRhZ3MucHVzaChganNvbjpcIiR7bmFtZX1cImApO1xuXG4gIC8vIOagueaNrumAieaLqeeahOagh+etvuexu+Wei+a3u+WKoOWvueW6lOeahOagh+etvlxuICBzd2l0Y2ggKG9wdGlvbnMudGFnVHlwZSkge1xuICAgIGNhc2UgXCJkYlwiOlxuICAgICAgdGFncy5wdXNoKGBkYjpcIiR7bmFtZX1cImApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImdvcm1cIjpcbiAgICAgIGNvbnN0IGdvcm1UYWdzOiBzdHJpbmdbXSA9IFtuYW1lXTtcbiAgICAgIGlmIChzcWxUeXBlID09PSBcImRhdGV0aW1lXCIgfHwgc3FsVHlwZSA9PT0gXCJ0aW1lc3RhbXBcIikge1xuICAgICAgICBnb3JtVGFncy5wdXNoKFwiYXV0b0NyZWF0ZVRpbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJpZFwiKSB7XG4gICAgICAgIGdvcm1UYWdzLnB1c2goXCJwcmltYXJ5S2V5XCIpO1xuICAgICAgfVxuICAgICAgdGFncy5wdXNoKGBnb3JtOlwiJHtnb3JtVGFncy5qb2luKCc7Jyl9XCJgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4b3JtXCI6XG4gICAgICBjb25zdCB4b3JtVGFnczogc3RyaW5nW10gPSBbbmFtZV07XG4gICAgICBpZiAoc3FsVHlwZSA9PT0gXCJkYXRldGltZVwiIHx8IHNxbFR5cGUgPT09IFwidGltZXN0YW1wXCIpIHtcbiAgICAgICAgeG9ybVRhZ3MucHVzaChcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJpZFwiKSB7XG4gICAgICAgIHhvcm1UYWdzLnB1c2goXCJwa1wiKTtcbiAgICAgIH1cbiAgICAgIHRhZ3MucHVzaChgeG9ybTpcIiR7eG9ybVRhZ3Muam9pbignICcpfVwiYCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0YWdzLmpvaW4oXCIgXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FsVG9Hb1N0cnVjdChzcWw6IHN0cmluZywgb3B0aW9uczogU1FMT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmVzID0gc3FsLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBzdHJ1Y3QgPSBcInR5cGUgQXV0b0dlbiBzdHJ1Y3Qge1xcblwiO1xuICBsZXQgaGFzVGltZUltcG9ydCA9IGZhbHNlO1xuICBsZXQgaGFzRGVjaW1hbEltcG9ydCA9IGZhbHNlO1xuICBsZXQgaGFzVVVJREltcG9ydCA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IG1hdGNoID0gbGluZS50cmltKCkubWF0Y2goL14oW2EtekEtWjAtOV9dKylcXHMrKFthLXpBLVpdKykoXFwoXFxkK1xcKSk/L2kpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgWywgbmFtZSwgdHlwZV0gPSBtYXRjaDtcbiAgICAgIGNvbnN0IHNxbFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBnb1R5cGUgPSBzcWxUeXBlTWFwW3NxbFR5cGVdPy5bb3B0aW9ucy5kYlR5cGVdIHx8IFwiaW50ZXJmYWNle31cIjtcblxuICAgICAgaWYgKGdvVHlwZSA9PT0gXCJ0aW1lLlRpbWVcIikge1xuICAgICAgICBoYXNUaW1lSW1wb3J0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ29UeXBlID09PSBcImRlY2ltYWwuRGVjaW1hbFwiKSB7XG4gICAgICAgIGhhc0RlY2ltYWxJbXBvcnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChnb1R5cGUgPT09IFwidXVpZC5VVUlEXCIpIHtcbiAgICAgICAgaGFzVVVJREltcG9ydCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGNhcGl0YWxpemVGaXJzdChuYW1lKTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IG9wdGlvbnMudXNlUG9pbnRlciAmJiBnb1R5cGUgIT09IFwiaW50ZXJmYWNle31cIiA/IFwiKlwiICsgZ29UeXBlIDogZ29UeXBlO1xuICAgICAgY29uc3QgdGFncyA9IGdlbmVyYXRlVGFncyhuYW1lLCBzcWxUeXBlLCBvcHRpb25zKTtcbiAgICAgIHN0cnVjdCArPSBcIlxcdFwiICsgZmllbGROYW1lICsgXCIgXCIgKyBmaWVsZFR5cGUgKyBcIiBgXCIgKyB0YWdzICsgXCJgXFxuXCI7XG4gICAgfVxuICB9XG5cbiAgc3RydWN0ICs9IFwifVxcblwiO1xuXG4gIC8vIOa3u+WKoOW/heimgeeahOWvvOWFpVxuICBjb25zdCBpbXBvcnRzOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAoaGFzVGltZUltcG9ydCkge1xuICAgIGltcG9ydHMucHVzaCgndGltZScpO1xuICB9XG4gIGlmIChoYXNEZWNpbWFsSW1wb3J0KSB7XG4gICAgaW1wb3J0cy5wdXNoKCdnaXRodWIuY29tL3Nob3BzcHJpbmcvZGVjaW1hbCcpO1xuICB9XG4gIGlmIChoYXNVVUlESW1wb3J0KSB7XG4gICAgaW1wb3J0cy5wdXNoKCdnaXRodWIuY29tL2dvb2dsZS91dWlkJyk7XG4gIH1cblxuICBpZiAoaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RydWN0ID0gJ2ltcG9ydCAoXFxuXFx0XCInICsgaW1wb3J0cy5qb2luKCdcIlxcblxcdFwiJykgKyAnXCJcXG4pXFxuXFxuJyArIHN0cnVjdDtcbiAgfVxuXG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmV4cG9ydCBjb25zdCBTUUxfVEVNUExBVEUgPSBgLS0g55So5oi36KGo56S65L6LXG5pZCBiaWdpbnRcbnVzZXJuYW1lIHZhcmNoYXIoMjU1KVxuZW1haWwgdmFyY2hhcigyNTUpXG5wYXNzd29yZCB2YXJjaGFyKDI1NSlcbmFnZSBpbnRcbmNyZWF0ZWRfYXQgZGF0ZXRpbWVcbnVwZGF0ZWRfYXQgdGltZXN0YW1wXG5pc19hY3RpdmUgYm9vbGVhblxucHJvZmlsZV9kYXRhIGpzb25cbmA7ICJdLCJuYW1lcyI6WyJZQU1MIiwiaW5mZXJHb1R5cGUiLCJ2YWx1ZSIsInNlZW4iLCJTZXQiLCJ1bmRlZmluZWQiLCJ0eXBlIiwiaXNQb2ludGVyIiwiaXNBcnJheSIsIkFycmF5IiwibGVuZ3RoIiwiZWxlbWVudFR5cGVzIiwibWFwIiwiaXRlbSIsImlzU2FtZVR5cGUiLCJldmVyeSIsInQiLCJlbGVtZW50VHlwZSIsIk51bWJlciIsImlzSW50ZWdlciIsImhhcyIsImFkZCIsImZvcm1hdEdvRmllbGRUeXBlIiwicmVzdWx0IiwiY2FwaXRhbGl6ZUZpcnN0Iiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImpzb25Ub0dvIiwib2JqIiwic3RydWN0TmFtZSIsIm5lc3RlZFN0cnVjdHMiLCJzdHJ1Y3QiLCJrZXkiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmllbGROYW1lIiwiZ29UeXBlIiwibmVzdGVkU3RydWN0TmFtZSIsImVsZW1lbnRWYWx1ZSIsInB1c2giLCJqb2luIiwiZm9ybWF0SlNPTiIsImlucHV0IiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZm9ybWF0WUFNTCIsImluZGVudCIsInNxbFR5cGVNYXAiLCJteXNxbCIsInBvc3RncmVzIiwic3FsaXRlIiwiZ2VuZXJhdGVUYWdzIiwibmFtZSIsInNxbFR5cGUiLCJvcHRpb25zIiwidGFncyIsInRhZ1R5cGUiLCJnb3JtVGFncyIsInhvcm1UYWdzIiwic3FsVG9Hb1N0cnVjdCIsInNxbCIsImxpbmVzIiwic3BsaXQiLCJoYXNUaW1lSW1wb3J0IiwiaGFzRGVjaW1hbEltcG9ydCIsImhhc1VVSURJbXBvcnQiLCJsaW5lIiwibWF0Y2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJkYlR5cGUiLCJmaWVsZFR5cGUiLCJ1c2VQb2ludGVyIiwiaW1wb3J0cyIsIlNRTF9URU1QTEFURSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/utils.ts\n"));

/***/ })

});