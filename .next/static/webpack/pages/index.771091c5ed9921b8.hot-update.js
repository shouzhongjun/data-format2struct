"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./pages/utils.ts":
/*!************************!*\
  !*** ./pages/utils.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SQL_TEMPLATE: () => (/* binding */ SQL_TEMPLATE),\n/* harmony export */   TEMPLATES: () => (/* binding */ TEMPLATES),\n/* harmony export */   convertToGo: () => (/* binding */ convertToGo),\n/* harmony export */   formatJSON: () => (/* binding */ formatJSON),\n/* harmony export */   formatYAML: () => (/* binding */ formatYAML),\n/* harmony export */   jsonToGo: () => (/* binding */ jsonToGo),\n/* harmony export */   sqlToGoStruct: () => (/* binding */ sqlToGoStruct),\n/* harmony export */   validateFormat: () => (/* binding */ validateFormat)\n/* harmony export */ });\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ \"(pages-dir-browser)/./node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/index.js\");\n\nfunction inferGoType(value) {\n    let seen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set();\n    if (value === null || value === undefined) {\n        return {\n            type: \"interface{}\",\n            isPointer: true,\n            isArray: false\n        };\n    }\n    if (Array.isArray(value)) {\n        if (value.length === 0) {\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: true\n            };\n        }\n        // 分析数组中的所有元素类型\n        const elementTypes = value.map((item)=>inferGoType(item, seen));\n        // 如果所有元素类型相同，使用该类型；否则使用 interface{}\n        const isSameType = elementTypes.every((t)=>t.type === elementTypes[0].type && t.isPointer === elementTypes[0].isPointer);\n        return {\n            type: isSameType ? elementTypes[0].type : \"interface{}\",\n            isPointer: isSameType ? elementTypes[0].isPointer : false,\n            isArray: true,\n            elementType: isSameType ? elementTypes[0] : undefined\n        };\n    }\n    switch(typeof value){\n        case \"string\":\n            return {\n                type: \"string\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"number\":\n            if (Number.isInteger(value)) {\n                if (value > 2147483647 || value < -2147483648) {\n                    return {\n                        type: \"int64\",\n                        isPointer: false,\n                        isArray: false\n                    };\n                }\n                return {\n                    type: \"int\",\n                    isPointer: false,\n                    isArray: false\n                };\n            }\n            return {\n                type: \"float64\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"boolean\":\n            return {\n                type: \"bool\",\n                isPointer: false,\n                isArray: false\n            };\n        case \"object\":\n            if (seen.has(value)) {\n                return {\n                    type: \"interface{}\",\n                    isPointer: true,\n                    isArray: false\n                };\n            }\n            seen.add(value);\n            return {\n                type: \"struct\",\n                isPointer: false,\n                isArray: false\n            };\n        default:\n            return {\n                type: \"interface{}\",\n                isPointer: false,\n                isArray: false\n            };\n    }\n}\nfunction formatGoFieldType(type) {\n    let result = \"\";\n    if (type.isArray) {\n        result += \"[]\";\n    }\n    if (type.isPointer) {\n        result += \"*\";\n    }\n    result += type.type;\n    return result;\n}\nfunction capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction jsonToGo(obj, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (typeof obj !== \"object\" || obj === null) {\n        return \"\";\n    }\n    if (seen.has(obj)) {\n        return \"\";\n    }\n    seen.add(obj);\n    const nestedStructs = [];\n    let struct = \"type \" + structName + \" struct {\\n\";\n    for (const [key, value] of Object.entries(obj)){\n        const fieldName = capitalizeFirst(key);\n        const goType = inferGoType(value, new Set(seen));\n        if (goType.type === \"struct\") {\n            const nestedStructName = structName + fieldName;\n            if (Array.isArray(value)) {\n                const elementValue = value[0];\n                if (elementValue && typeof elementValue === \"object\") {\n                    nestedStructs.push(jsonToGo(elementValue, nestedStructName, new Set(seen)));\n                    goType.type = nestedStructName;\n                }\n            } else {\n                nestedStructs.push(jsonToGo(value, nestedStructName, new Set(seen)));\n                goType.type = nestedStructName;\n            }\n        }\n        struct += \"\\t\" + fieldName + \" \" + formatGoFieldType(goType) + \" `json:\\\"\" + key + \"\\\" yaml:\\\"\" + key + \"\\\"`\\n\";\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join(\"\") + struct;\n}\nfunction formatJSON(input) {\n    try {\n        const parsed = JSON.parse(input);\n        return JSON.stringify(parsed, null, 2);\n    } catch (e) {\n        return input;\n    }\n}\nfunction formatYAML(input) {\n    try {\n        const parsed = yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n        return yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stringify(parsed, {\n            indent: 2\n        });\n    } catch (e) {\n        return input;\n    }\n}\nconst sqlTypeMap = {\n    \"int\": {\n        mysql: \"int\",\n        postgres: \"int\",\n        sqlite: \"int\",\n        oracle: \"int\"\n    },\n    \"bigint\": {\n        mysql: \"int64\",\n        postgres: \"int64\",\n        sqlite: \"int64\",\n        oracle: \"int64\"\n    },\n    \"tinyint\": {\n        mysql: \"int8\",\n        postgres: \"int8\",\n        sqlite: \"int8\",\n        oracle: \"int8\"\n    },\n    \"smallint\": {\n        mysql: \"int16\",\n        postgres: \"int16\",\n        sqlite: \"int16\",\n        oracle: \"int16\"\n    },\n    \"mediumint\": {\n        mysql: \"int32\",\n        postgres: \"int32\",\n        sqlite: \"int32\",\n        oracle: \"int32\"\n    },\n    \"float\": {\n        mysql: \"float32\",\n        postgres: \"float32\",\n        sqlite: \"float32\",\n        oracle: \"float32\"\n    },\n    \"double\": {\n        mysql: \"float64\",\n        postgres: \"float64\",\n        sqlite: \"float64\",\n        oracle: \"float64\"\n    },\n    \"decimal\": {\n        mysql: \"float64\",\n        postgres: \"decimal.Decimal\",\n        sqlite: \"float64\",\n        oracle: \"decimal.Decimal\"\n    },\n    \"number\": {\n        mysql: \"float64\",\n        postgres: \"decimal.Decimal\",\n        sqlite: \"float64\",\n        oracle: \"decimal.Decimal\"\n    },\n    \"varchar\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"varchar2\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"nvarchar2\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"char\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"nchar\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"text\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"clob\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"nclob\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"mediumtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"longtext\": {\n        mysql: \"string\",\n        postgres: \"string\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"datetime\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\",\n        oracle: \"time.Time\"\n    },\n    \"timestamp\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\",\n        oracle: \"time.Time\"\n    },\n    \"date\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\",\n        oracle: \"time.Time\"\n    },\n    \"time\": {\n        mysql: \"time.Time\",\n        postgres: \"time.Time\",\n        sqlite: \"time.Time\",\n        oracle: \"time.Time\"\n    },\n    \"boolean\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\",\n        oracle: \"bool\"\n    },\n    \"bool\": {\n        mysql: \"bool\",\n        postgres: \"bool\",\n        sqlite: \"bool\",\n        oracle: \"bool\"\n    },\n    \"json\": {\n        mysql: \"interface{}\",\n        postgres: \"interface{}\",\n        sqlite: \"interface{}\",\n        oracle: \"interface{}\"\n    },\n    \"uuid\": {\n        mysql: \"string\",\n        postgres: \"uuid.UUID\",\n        sqlite: \"string\",\n        oracle: \"string\"\n    },\n    \"raw\": {\n        mysql: \"[]byte\",\n        postgres: \"[]byte\",\n        sqlite: \"[]byte\",\n        oracle: \"[]byte\"\n    },\n    \"blob\": {\n        mysql: \"[]byte\",\n        postgres: \"[]byte\",\n        sqlite: \"[]byte\",\n        oracle: \"[]byte\"\n    }\n};\nfunction generateTags(name, sqlType, options) {\n    const tags = [];\n    // 添加 json 标签\n    tags.push('json:\"'.concat(name, '\"'));\n    // 根据选择的标签类型添加对应的标签\n    switch(options.tagType){\n        case \"db\":\n            tags.push('db:\"'.concat(name, '\"'));\n            break;\n        case \"gorm\":\n            const gormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                gormTags.push(\"autoCreateTime\");\n            }\n            if (name === \"id\") {\n                gormTags.push(\"primaryKey\");\n            }\n            tags.push('gorm:\"'.concat(gormTags.join(';'), '\"'));\n            break;\n        case \"xorm\":\n            const xormTags = [\n                name\n            ];\n            if (sqlType === \"datetime\" || sqlType === \"timestamp\") {\n                xormTags.push(\"created\");\n            }\n            if (name === \"id\") {\n                xormTags.push(\"pk\");\n            }\n            tags.push('xorm:\"'.concat(xormTags.join(' '), '\"'));\n            break;\n    }\n    return tags.join(\" \");\n}\nfunction sqlToGoStruct(sql, options) {\n    const lines = sql.split(/\\r?\\n/);\n    let struct = \"type AutoGen struct {\\n\";\n    let hasTimeImport = false;\n    let hasDecimalImport = false;\n    let hasUUIDImport = false;\n    for (const line of lines){\n        const match = line.trim().match(/^([a-zA-Z0-9_]+)\\s+([a-zA-Z]+)(\\(\\d+\\))?/i);\n        if (match) {\n            var _sqlTypeMap_sqlType;\n            const [, name, type] = match;\n            const sqlType = type.toLowerCase();\n            const goType = ((_sqlTypeMap_sqlType = sqlTypeMap[sqlType]) === null || _sqlTypeMap_sqlType === void 0 ? void 0 : _sqlTypeMap_sqlType[options.dbType]) || \"interface{}\";\n            if (goType === \"time.Time\") {\n                hasTimeImport = true;\n            } else if (goType === \"decimal.Decimal\") {\n                hasDecimalImport = true;\n            } else if (goType === \"uuid.UUID\") {\n                hasUUIDImport = true;\n            }\n            const fieldName = capitalizeFirst(name);\n            const fieldType = options.usePointer && goType !== \"interface{}\" ? \"*\" + goType : goType;\n            const tags = generateTags(name, sqlType, options);\n            struct += \"\\t\" + fieldName + \" \" + fieldType + \" `\" + tags + \"`\\n\";\n        }\n    }\n    struct += \"}\\n\";\n    // 添加必要的导入\n    const imports = [];\n    if (hasTimeImport) {\n        imports.push('time');\n    }\n    if (hasDecimalImport) {\n        imports.push('github.com/shopspring/decimal');\n    }\n    if (hasUUIDImport) {\n        imports.push('github.com/google/uuid');\n    }\n    if (imports.length > 0) {\n        struct = 'import (\\n\\t\"' + imports.join('\"\\n\\t\"') + '\"\\n)\\n\\n' + struct;\n    }\n    return struct;\n}\nconst SQL_TEMPLATE = \"-- 用户表示例\\nid bigint\\nusername varchar(255)\\nemail varchar(255)\\npassword varchar(255)\\nage int\\ncreated_at datetime\\nupdated_at timestamp\\nis_active boolean\\nprofile_data json\\n\";\n// 添加格式校验函数\nfunction validateFormat(input, type) {\n    if (!input.trim()) {\n        return {\n            isValid: false,\n            error: \"输入内容为空\"\n        };\n    }\n    try {\n        switch(type){\n            case 'json':\n                JSON.parse(input);\n                return {\n                    isValid: true\n                };\n            case 'yaml':\n                yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input);\n                return {\n                    isValid: true\n                };\n            case 'sql':\n                const sqlLines = input.split(/\\r?\\n/).filter((line)=>line.trim() && !line.startsWith('--'));\n                if (sqlLines.length === 0) {\n                    return {\n                        isValid: false,\n                        error: \"没有找到有效的 SQL 字段定义\"\n                    };\n                }\n                for (const line of sqlLines){\n                    const match = line.trim().match(/^[a-zA-Z0-9_]+\\s+[a-zA-Z]+(\\(\\d+\\))?$/i);\n                    if (!match) {\n                        return {\n                            isValid: false,\n                            error: \"无效的 SQL 字段定义: \".concat(line)\n                        };\n                    }\n                }\n                return {\n                    isValid: true\n                };\n            case 'proto':\n                if (!input.includes('message')) {\n                    return {\n                        isValid: false,\n                        error: \"未找到 message 定义\"\n                    };\n                }\n                return {\n                    isValid: true\n                };\n            case 'xml':\n                new DOMParser().parseFromString(input, 'text/xml');\n                return {\n                    isValid: true\n                };\n            case 'csv':\n                const csvLines = input.split(/\\r?\\n/).filter((line)=>line.trim());\n                if (csvLines.length < 2) {\n                    return {\n                        isValid: false,\n                        error: \"CSV 至少需要包含标题行和一行数据\"\n                    };\n                }\n                return {\n                    isValid: true\n                };\n            default:\n                return {\n                    isValid: false,\n                    error: \"不支持的格式类型\"\n                };\n        }\n    } catch (e) {\n        return {\n            isValid: false,\n            error: \"格式错误: \".concat(e instanceof Error ? e.message : '未知错误')\n        };\n    }\n}\n// 添加示例模板\nconst TEMPLATES = {\n    json: '{\\n  \"id\": 1,\\n  \"name\": \"example\",\\n  \"age\": 25,\\n  \"email\": \"test@example.com\",\\n  \"is_active\": true,\\n  \"created_at\": \"2024-03-21T12:00:00Z\",\\n  \"tags\": [\"tag1\", \"tag2\"],\\n  \"profile\": {\\n    \"address\": \"123 Street\",\\n    \"phone\": \"1234567890\"\\n  }\\n}',\n    yaml: 'id: 1\\nname: example\\nage: 25\\nemail: test@example.com\\nis_active: true\\ncreated_at: 2024-03-21T12:00:00Z\\ntags:\\n  - tag1\\n  - tag2\\nprofile:\\n  address: 123 Street\\n  phone: \"1234567890\"',\n    sql: SQL_TEMPLATE,\n    proto: 'syntax = \"proto3\";\\n\\npackage example;\\n\\nmessage User {\\n  int64 id = 1;\\n  string name = 2;\\n  int32 age = 3;\\n  string email = 4;\\n  bool is_active = 5;\\n  string created_at = 6;\\n  repeated string tags = 7;\\n  Profile profile = 8;\\n}\\n\\nmessage Profile {\\n  string address = 1;\\n  string phone = 2;\\n}',\n    xml: '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<user>\\n  <id>1</id>\\n  <name>example</name>\\n  <age>25</age>\\n  <email>test@example.com</email>\\n  <is_active>true</is_active>\\n  <created_at>2024-03-21T12:00:00Z</created_at>\\n  <tags>\\n    <tag>tag1</tag>\\n    <tag>tag2</tag>\\n  </tags>\\n  <profile>\\n    <address>123 Street</address>\\n    <phone>1234567890</phone>\\n  </profile>\\n</user>',\n    csv: \"id,name,age,email,is_active,created_at\\n1,example,25,test@example.com,true,2024-03-21T12:00:00Z\"\n};\n// Proto 转 Go 结构体\nfunction protoToGo(proto) {\n    const lines = proto.split(/\\r?\\n/);\n    let output = \"\";\n    let currentMessage = \"\";\n    let imports = new Set();\n    for (const line of lines){\n        // 忽略空行和 proto 语法声明\n        if (!line.trim() || line.includes('syntax') || line.includes('package')) {\n            continue;\n        }\n        // 处理消息定义\n        if (line.includes('message')) {\n            var _line_match;\n            if (currentMessage) {\n                output += \"}\\n\\n\";\n            }\n            const messageName = (_line_match = line.match(/message\\s+(\\w+)/)) === null || _line_match === void 0 ? void 0 : _line_match[1];\n            if (messageName) {\n                currentMessage = messageName;\n                output += \"type \".concat(messageName, \" struct {\\n\");\n            }\n            continue;\n        }\n        // 处理字段\n        if (currentMessage && line.trim()) {\n            const fieldMatch = line.match(/\\s*(repeated)?\\s*(\\w+)\\s+(\\w+)\\s*=\\s*\\d+;/);\n            if (fieldMatch) {\n                const [, repeated, type, name] = fieldMatch;\n                const goType = protoTypeToGo(type);\n                const fieldName = capitalizeFirst(name);\n                const fieldType = repeated ? \"[]\".concat(goType) : goType;\n                if (goType === \"time.Time\") {\n                    imports.add('time');\n                }\n                output += \"\t\".concat(fieldName, \" \").concat(fieldType, ' `json:\"').concat(name, '\"`\\n');\n            }\n        }\n    }\n    if (currentMessage) {\n        output += \"}\\n\";\n    }\n    if (imports.size > 0) {\n        output = 'import (\\n\\t\"' + Array.from(imports).join('\"\\n\\t\"') + '\"\\n)\\n\\n' + output;\n    }\n    return output;\n}\n// Proto 类型转 Go 类型\nfunction protoTypeToGo(type) {\n    const typeMap = {\n        'double': 'float64',\n        'float': 'float32',\n        'int32': 'int32',\n        'int64': 'int64',\n        'uint32': 'uint32',\n        'uint64': 'uint64',\n        'sint32': 'int32',\n        'sint64': 'int64',\n        'fixed32': 'uint32',\n        'fixed64': 'uint64',\n        'sfixed32': 'int32',\n        'sfixed64': 'int64',\n        'bool': 'bool',\n        'string': 'string',\n        'bytes': '[]byte',\n        'Timestamp': 'time.Time'\n    };\n    return typeMap[type] || type;\n}\n// XML 转 Go 结构体\nfunction xmlToGo(xml) {\n    try {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(xml, 'text/xml');\n        const root = doc.documentElement;\n        return processXMLNode(root, capitalizeFirst(root.tagName));\n    } catch (e) {\n        throw new Error('XML 解析错误');\n    }\n}\nfunction processXMLNode(node, structName) {\n    let seen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set();\n    if (seen.has(structName)) {\n        return '';\n    }\n    seen.add(structName);\n    let struct = \"type \".concat(structName, \" struct {\\n\");\n    const nestedStructs = [];\n    const fields = new Map();\n    // 处理子元素\n    for (const child of Array.from(node.children)){\n        const fieldName = capitalizeFirst(child.tagName);\n        const existingField = fields.get(fieldName);\n        if (child.children.length === 0 || child.children.length === 1 && child.children[0].nodeType === 3) {\n            var _child_textContent;\n            // 简单值\n            const value = ((_child_textContent = child.textContent) === null || _child_textContent === void 0 ? void 0 : _child_textContent.trim()) || '';\n            const type = inferTypeFromValue(value);\n            if (existingField) {\n                existingField.isArray = true;\n            } else {\n                fields.set(fieldName, {\n                    type,\n                    isArray: false\n                });\n            }\n        } else {\n            // 复杂类型\n            const nestedStructName = structName + fieldName;\n            nestedStructs.push(processXMLNode(child, nestedStructName, seen));\n            if (existingField) {\n                existingField.isArray = true;\n            } else {\n                fields.set(fieldName, {\n                    type: nestedStructName,\n                    isArray: false\n                });\n            }\n        }\n    }\n    // 生成字段\n    for (const [fieldName, { type, isArray }] of fields){\n        const fieldType = isArray ? \"[]\".concat(type) : type;\n        struct += \"\t\".concat(fieldName, \" \").concat(fieldType, ' `xml:\"').concat(fieldName.toLowerCase(), '\" json:\"').concat(fieldName.toLowerCase(), '\"`\\n');\n    }\n    struct += \"}\\n\\n\";\n    return nestedStructs.join('') + struct;\n}\nfunction inferTypeFromValue(value) {\n    if (value === 'true' || value === 'false') return 'bool';\n    if (/^\\d+$/.test(value)) return 'int';\n    if (/^\\d*\\.\\d+$/.test(value)) return 'float64';\n    if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)) return 'time.Time';\n    return 'string';\n}\n// CSV 转 Go 结构体\nfunction csvToGo(csv) {\n    const lines = csv.split(/\\r?\\n/).filter((line)=>line.trim());\n    if (lines.length < 2) {\n        throw new Error('CSV 至少需要包含标题行和一行数据');\n    }\n    const headers = lines[0].split(',').map((h)=>h.trim());\n    const firstRow = lines[1].split(',').map((v)=>v.trim());\n    let struct = \"type AutoGen struct {\\n\";\n    for(let i = 0; i < headers.length; i++){\n        const fieldName = capitalizeFirst(headers[i]);\n        const value = firstRow[i];\n        const type = inferTypeFromValue(value);\n        struct += \"\t\".concat(fieldName, \" \").concat(type, ' `json:\"').concat(headers[i], '\"`\\n');\n    }\n    struct += \"}\\n\";\n    return struct;\n}\n// 导出新的转换函数\nfunction convertToGo(input, type, options) {\n    switch(type){\n        case 'json':\n            return jsonToGo(JSON.parse(input), 'AutoGen');\n        case 'yaml':\n            return jsonToGo(yaml__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(input), 'AutoGen');\n        case 'sql':\n            return sqlToGoStruct(input, options);\n        case 'proto':\n            return protoToGo(input);\n        case 'xml':\n            return xmlToGo(input);\n        case 'csv':\n            return csvToGo(input);\n        default:\n            throw new Error('不支持的格式类型');\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVM7UUFDUEgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNOSCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFDQSxRQUFRO1FBQ05ILE9BQU87UUFDUEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBLFNBQVM7UUFDUEgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsY0FBYztRQUNaSCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFDQSxZQUFZO1FBQ1ZILE9BQU87UUFDUEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBLFlBQVk7UUFDVkgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsYUFBYTtRQUNYSCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFDQSxRQUFRO1FBQ05ILE9BQU87UUFDUEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUNUSCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFDQSxRQUFRO1FBQ05ILE9BQU87UUFDUEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsUUFBUTtRQUNOSCxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7SUFDQSxPQUFPO1FBQ0xILE9BQU87UUFDUEMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBLFFBQVE7UUFDTkgsT0FBTztR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dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgWUFNTCBmcm9tICd5YW1sJztcbmltcG9ydCB7IFNRTE9wdGlvbnMsIERCVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgR29UeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBpc1BvaW50ZXI6IGJvb2xlYW47XG4gIGlzQXJyYXk6IGJvb2xlYW47XG4gIGVsZW1lbnRUeXBlPzogR29UeXBlO1xufVxuXG5mdW5jdGlvbiBpbmZlckdvVHlwZSh2YWx1ZTogYW55LCBzZWVuID0gbmV3IFNldDxhbnk+KCkpOiBHb1R5cGUge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiB0cnVlLCBpc0FycmF5OiBmYWxzZSB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiB0cnVlIH07XG4gICAgfVxuICAgIC8vIOWIhuaekOaVsOe7hOS4reeahOaJgOacieWFg+e0oOexu+Wei1xuICAgIGNvbnN0IGVsZW1lbnRUeXBlcyA9IHZhbHVlLm1hcChpdGVtID0+IGluZmVyR29UeXBlKGl0ZW0sIHNlZW4pKTtcbiAgICAvLyDlpoLmnpzmiYDmnInlhYPntKDnsbvlnovnm7jlkIzvvIzkvb/nlKjor6XnsbvlnovvvJvlkKbliJnkvb/nlKggaW50ZXJmYWNle31cbiAgICBjb25zdCBpc1NhbWVUeXBlID0gZWxlbWVudFR5cGVzLmV2ZXJ5KHQgPT4gXG4gICAgICB0LnR5cGUgPT09IGVsZW1lbnRUeXBlc1swXS50eXBlICYmIFxuICAgICAgdC5pc1BvaW50ZXIgPT09IGVsZW1lbnRUeXBlc1swXS5pc1BvaW50ZXJcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBpc1NhbWVUeXBlID8gZWxlbWVudFR5cGVzWzBdLnR5cGUgOiBcImludGVyZmFjZXt9XCIsXG4gICAgICBpc1BvaW50ZXI6IGlzU2FtZVR5cGUgPyBlbGVtZW50VHlwZXNbMF0uaXNQb2ludGVyIDogZmFsc2UsXG4gICAgICBpc0FycmF5OiB0cnVlLFxuICAgICAgZWxlbWVudFR5cGU6IGlzU2FtZVR5cGUgPyBlbGVtZW50VHlwZXNbMF0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgPiAyMTQ3NDgzNjQ3IHx8IHZhbHVlIDwgLTIxNDc0ODM2NDgpIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImludDY0XCIsIGlzUG9pbnRlcjogZmFsc2UsIGlzQXJyYXk6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZmxvYXQ2NFwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImJvb2xcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJmYWNle31cIiwgaXNQb2ludGVyOiB0cnVlLCBpc0FycmF5OiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJ1Y3RcIiwgaXNQb2ludGVyOiBmYWxzZSwgaXNBcnJheTogZmFsc2UgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcmZhY2V7fVwiLCBpc1BvaW50ZXI6IGZhbHNlLCBpc0FycmF5OiBmYWxzZSB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEdvRmllbGRUeXBlKHR5cGU6IEdvVHlwZSk6IHN0cmluZyB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBpZiAodHlwZS5pc0FycmF5KSB7XG4gICAgcmVzdWx0ICs9IFwiW11cIjtcbiAgfVxuICBpZiAodHlwZS5pc1BvaW50ZXIpIHtcbiAgICByZXN1bHQgKz0gXCIqXCI7XG4gIH1cbiAgcmVzdWx0ICs9IHR5cGUudHlwZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpzb25Ub0dvKG9iajogYW55LCBzdHJ1Y3ROYW1lOiBzdHJpbmcsIHNlZW4gPSBuZXcgU2V0PGFueT4oKSk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgaWYgKHNlZW4uaGFzKG9iaikpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBzZWVuLmFkZChvYmopO1xuXG4gIGNvbnN0IG5lc3RlZFN0cnVjdHM6IHN0cmluZ1tdID0gW107XG4gIGxldCBzdHJ1Y3QgPSBcInR5cGUgXCIgKyBzdHJ1Y3ROYW1lICsgXCIgc3RydWN0IHtcXG5cIjtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gY2FwaXRhbGl6ZUZpcnN0KGtleSk7XG4gICAgY29uc3QgZ29UeXBlID0gaW5mZXJHb1R5cGUodmFsdWUsIG5ldyBTZXQoc2VlbikpO1xuXG4gICAgaWYgKGdvVHlwZS50eXBlID09PSBcInN0cnVjdFwiKSB7XG4gICAgICBjb25zdCBuZXN0ZWRTdHJ1Y3ROYW1lID0gc3RydWN0TmFtZSArIGZpZWxkTmFtZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZSAmJiB0eXBlb2YgZWxlbWVudFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmVzdGVkU3RydWN0cy5wdXNoKGpzb25Ub0dvKGVsZW1lbnRWYWx1ZSwgbmVzdGVkU3RydWN0TmFtZSwgbmV3IFNldChzZWVuKSkpO1xuICAgICAgICAgIGdvVHlwZS50eXBlID0gbmVzdGVkU3RydWN0TmFtZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVzdGVkU3RydWN0cy5wdXNoKGpzb25Ub0dvKHZhbHVlLCBuZXN0ZWRTdHJ1Y3ROYW1lLCBuZXcgU2V0KHNlZW4pKSk7XG4gICAgICAgIGdvVHlwZS50eXBlID0gbmVzdGVkU3RydWN0TmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJ1Y3QgKz0gXCJcXHRcIiArIGZpZWxkTmFtZSArIFwiIFwiICsgZm9ybWF0R29GaWVsZFR5cGUoZ29UeXBlKSArIFwiIGBqc29uOlxcXCJcIiArIGtleSArIFwiXFxcIiB5YW1sOlxcXCJcIiArIGtleSArIFwiXFxcImBcXG5cIjtcbiAgfVxuXG4gIHN0cnVjdCArPSBcIn1cXG5cXG5cIjtcbiAgcmV0dXJuIG5lc3RlZFN0cnVjdHMuam9pbihcIlwiKSArIHN0cnVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEpTT04oaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZCwgbnVsbCwgMik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0WUFNTChpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBZQU1MLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gWUFNTC5zdHJpbmdpZnkocGFyc2VkLCB7IGluZGVudDogMiB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59XG5cbmNvbnN0IHNxbFR5cGVNYXA6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxEQlR5cGUsIHN0cmluZz4+ID0ge1xuICBcImludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50XCIsXG4gICAgc3FsaXRlOiBcImludFwiLFxuICAgIG9yYWNsZTogXCJpbnRcIixcbiAgfSxcbiAgXCJiaWdpbnRcIjoge1xuICAgIG15c3FsOiBcImludDY0XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50NjRcIixcbiAgICBzcWxpdGU6IFwiaW50NjRcIixcbiAgICBvcmFjbGU6IFwiaW50NjRcIixcbiAgfSxcbiAgXCJ0aW55aW50XCI6IHtcbiAgICBteXNxbDogXCJpbnQ4XCIsXG4gICAgcG9zdGdyZXM6IFwiaW50OFwiLFxuICAgIHNxbGl0ZTogXCJpbnQ4XCIsXG4gICAgb3JhY2xlOiBcImludDhcIixcbiAgfSxcbiAgXCJzbWFsbGludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50MTZcIixcbiAgICBwb3N0Z3JlczogXCJpbnQxNlwiLFxuICAgIHNxbGl0ZTogXCJpbnQxNlwiLFxuICAgIG9yYWNsZTogXCJpbnQxNlwiLFxuICB9LFxuICBcIm1lZGl1bWludFwiOiB7XG4gICAgbXlzcWw6IFwiaW50MzJcIixcbiAgICBwb3N0Z3JlczogXCJpbnQzMlwiLFxuICAgIHNxbGl0ZTogXCJpbnQzMlwiLFxuICAgIG9yYWNsZTogXCJpbnQzMlwiLFxuICB9LFxuICBcImZsb2F0XCI6IHtcbiAgICBteXNxbDogXCJmbG9hdDMyXCIsXG4gICAgcG9zdGdyZXM6IFwiZmxvYXQzMlwiLFxuICAgIHNxbGl0ZTogXCJmbG9hdDMyXCIsXG4gICAgb3JhY2xlOiBcImZsb2F0MzJcIixcbiAgfSxcbiAgXCJkb3VibGVcIjoge1xuICAgIG15c3FsOiBcImZsb2F0NjRcIixcbiAgICBwb3N0Z3JlczogXCJmbG9hdDY0XCIsXG4gICAgc3FsaXRlOiBcImZsb2F0NjRcIixcbiAgICBvcmFjbGU6IFwiZmxvYXQ2NFwiLFxuICB9LFxuICBcImRlY2ltYWxcIjoge1xuICAgIG15c3FsOiBcImZsb2F0NjRcIixcbiAgICBwb3N0Z3JlczogXCJkZWNpbWFsLkRlY2ltYWxcIixcbiAgICBzcWxpdGU6IFwiZmxvYXQ2NFwiLFxuICAgIG9yYWNsZTogXCJkZWNpbWFsLkRlY2ltYWxcIixcbiAgfSxcbiAgXCJudW1iZXJcIjogeyAgLy8gT3JhY2xlIOeJueacieexu+Wei1xuICAgIG15c3FsOiBcImZsb2F0NjRcIixcbiAgICBwb3N0Z3JlczogXCJkZWNpbWFsLkRlY2ltYWxcIixcbiAgICBzcWxpdGU6IFwiZmxvYXQ2NFwiLFxuICAgIG9yYWNsZTogXCJkZWNpbWFsLkRlY2ltYWxcIixcbiAgfSxcbiAgXCJ2YXJjaGFyXCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcInZhcmNoYXIyXCI6IHsgIC8vIE9yYWNsZSDnibnmnInnsbvlnotcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcIm52YXJjaGFyMlwiOiB7ICAvLyBPcmFjbGUg54m55pyJ57G75Z6LXG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICAgIG9yYWNsZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJjaGFyXCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcIm5jaGFyXCI6IHsgIC8vIE9yYWNsZSDnibnmnInnsbvlnotcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcInRleHRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInN0cmluZ1wiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgICBvcmFjbGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwiY2xvYlwiOiB7ICAvLyBPcmFjbGUg54m55pyJ57G75Z6LXG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICAgIG9yYWNsZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJuY2xvYlwiOiB7ICAvLyBPcmFjbGUg54m55pyJ57G75Z6LXG4gICAgbXlzcWw6IFwic3RyaW5nXCIsXG4gICAgcG9zdGdyZXM6IFwic3RyaW5nXCIsXG4gICAgc3FsaXRlOiBcInN0cmluZ1wiLFxuICAgIG9yYWNsZTogXCJzdHJpbmdcIixcbiAgfSxcbiAgXCJtZWRpdW10ZXh0XCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcImxvbmd0ZXh0XCI6IHtcbiAgICBteXNxbDogXCJzdHJpbmdcIixcbiAgICBwb3N0Z3JlczogXCJzdHJpbmdcIixcbiAgICBzcWxpdGU6IFwic3RyaW5nXCIsXG4gICAgb3JhY2xlOiBcInN0cmluZ1wiLFxuICB9LFxuICBcImRhdGV0aW1lXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gICAgb3JhY2xlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcInRpbWVzdGFtcFwiOiB7XG4gICAgbXlzcWw6IFwidGltZS5UaW1lXCIsXG4gICAgcG9zdGdyZXM6IFwidGltZS5UaW1lXCIsXG4gICAgc3FsaXRlOiBcInRpbWUuVGltZVwiLFxuICAgIG9yYWNsZTogXCJ0aW1lLlRpbWVcIixcbiAgfSxcbiAgXCJkYXRlXCI6IHtcbiAgICBteXNxbDogXCJ0aW1lLlRpbWVcIixcbiAgICBwb3N0Z3JlczogXCJ0aW1lLlRpbWVcIixcbiAgICBzcWxpdGU6IFwidGltZS5UaW1lXCIsXG4gICAgb3JhY2xlOiBcInRpbWUuVGltZVwiLFxuICB9LFxuICBcInRpbWVcIjoge1xuICAgIG15c3FsOiBcInRpbWUuVGltZVwiLFxuICAgIHBvc3RncmVzOiBcInRpbWUuVGltZVwiLFxuICAgIHNxbGl0ZTogXCJ0aW1lLlRpbWVcIixcbiAgICBvcmFjbGU6IFwidGltZS5UaW1lXCIsXG4gIH0sXG4gIFwiYm9vbGVhblwiOiB7XG4gICAgbXlzcWw6IFwiYm9vbFwiLFxuICAgIHBvc3RncmVzOiBcImJvb2xcIixcbiAgICBzcWxpdGU6IFwiYm9vbFwiLFxuICAgIG9yYWNsZTogXCJib29sXCIsXG4gIH0sXG4gIFwiYm9vbFwiOiB7XG4gICAgbXlzcWw6IFwiYm9vbFwiLFxuICAgIHBvc3RncmVzOiBcImJvb2xcIixcbiAgICBzcWxpdGU6IFwiYm9vbFwiLFxuICAgIG9yYWNsZTogXCJib29sXCIsXG4gIH0sXG4gIFwianNvblwiOiB7XG4gICAgbXlzcWw6IFwiaW50ZXJmYWNle31cIixcbiAgICBwb3N0Z3JlczogXCJpbnRlcmZhY2V7fVwiLFxuICAgIHNxbGl0ZTogXCJpbnRlcmZhY2V7fVwiLFxuICAgIG9yYWNsZTogXCJpbnRlcmZhY2V7fVwiLFxuICB9LFxuICBcInV1aWRcIjoge1xuICAgIG15c3FsOiBcInN0cmluZ1wiLFxuICAgIHBvc3RncmVzOiBcInV1aWQuVVVJRFwiLFxuICAgIHNxbGl0ZTogXCJzdHJpbmdcIixcbiAgICBvcmFjbGU6IFwic3RyaW5nXCIsXG4gIH0sXG4gIFwicmF3XCI6IHsgIC8vIE9yYWNsZSDnibnmnInnsbvlnotcbiAgICBteXNxbDogXCJbXWJ5dGVcIixcbiAgICBwb3N0Z3JlczogXCJbXWJ5dGVcIixcbiAgICBzcWxpdGU6IFwiW11ieXRlXCIsXG4gICAgb3JhY2xlOiBcIltdYnl0ZVwiLFxuICB9LFxuICBcImJsb2JcIjogeyAgLy8gT3JhY2xlIOeJueacieexu+Wei1xuICAgIG15c3FsOiBcIltdYnl0ZVwiLFxuICAgIHBvc3RncmVzOiBcIltdYnl0ZVwiLFxuICAgIHNxbGl0ZTogXCJbXWJ5dGVcIixcbiAgICBvcmFjbGU6IFwiW11ieXRlXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhZ3MobmFtZTogc3RyaW5nLCBzcWxUeXBlOiBzdHJpbmcsIG9wdGlvbnM6IFNRTE9wdGlvbnMpOiBzdHJpbmcge1xuICBjb25zdCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIOa3u+WKoCBqc29uIOagh+etvlxuICB0YWdzLnB1c2goYGpzb246XCIke25hbWV9XCJgKTtcblxuICAvLyDmoLnmja7pgInmi6nnmoTmoIfnrb7nsbvlnovmt7vliqDlr7nlupTnmoTmoIfnrb5cbiAgc3dpdGNoIChvcHRpb25zLnRhZ1R5cGUpIHtcbiAgICBjYXNlIFwiZGJcIjpcbiAgICAgIHRhZ3MucHVzaChgZGI6XCIke25hbWV9XCJgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJnb3JtXCI6XG4gICAgICBjb25zdCBnb3JtVGFnczogc3RyaW5nW10gPSBbbmFtZV07XG4gICAgICBpZiAoc3FsVHlwZSA9PT0gXCJkYXRldGltZVwiIHx8IHNxbFR5cGUgPT09IFwidGltZXN0YW1wXCIpIHtcbiAgICAgICAgZ29ybVRhZ3MucHVzaChcImF1dG9DcmVhdGVUaW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwiaWRcIikge1xuICAgICAgICBnb3JtVGFncy5wdXNoKFwicHJpbWFyeUtleVwiKTtcbiAgICAgIH1cbiAgICAgIHRhZ3MucHVzaChgZ29ybTpcIiR7Z29ybVRhZ3Muam9pbignOycpfVwiYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieG9ybVwiOlxuICAgICAgY29uc3QgeG9ybVRhZ3M6IHN0cmluZ1tdID0gW25hbWVdO1xuICAgICAgaWYgKHNxbFR5cGUgPT09IFwiZGF0ZXRpbWVcIiB8fCBzcWxUeXBlID09PSBcInRpbWVzdGFtcFwiKSB7XG4gICAgICAgIHhvcm1UYWdzLnB1c2goXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwiaWRcIikge1xuICAgICAgICB4b3JtVGFncy5wdXNoKFwicGtcIik7XG4gICAgICB9XG4gICAgICB0YWdzLnB1c2goYHhvcm06XCIke3hvcm1UYWdzLmpvaW4oJyAnKX1cImApO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGFncy5qb2luKFwiIFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxbFRvR29TdHJ1Y3Qoc3FsOiBzdHJpbmcsIG9wdGlvbnM6IFNRTE9wdGlvbnMpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lcyA9IHNxbC5zcGxpdCgvXFxyP1xcbi8pO1xuICBsZXQgc3RydWN0ID0gXCJ0eXBlIEF1dG9HZW4gc3RydWN0IHtcXG5cIjtcbiAgbGV0IGhhc1RpbWVJbXBvcnQgPSBmYWxzZTtcbiAgbGV0IGhhc0RlY2ltYWxJbXBvcnQgPSBmYWxzZTtcbiAgbGV0IGhhc1VVSURJbXBvcnQgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUudHJpbSgpLm1hdGNoKC9eKFthLXpBLVowLTlfXSspXFxzKyhbYS16QS1aXSspKFxcKFxcZCtcXCkpPy9pKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIG5hbWUsIHR5cGVdID0gbWF0Y2g7XG4gICAgICBjb25zdCBzcWxUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgZ29UeXBlID0gc3FsVHlwZU1hcFtzcWxUeXBlXT8uW29wdGlvbnMuZGJUeXBlXSB8fCBcImludGVyZmFjZXt9XCI7XG5cbiAgICAgIGlmIChnb1R5cGUgPT09IFwidGltZS5UaW1lXCIpIHtcbiAgICAgICAgaGFzVGltZUltcG9ydCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdvVHlwZSA9PT0gXCJkZWNpbWFsLkRlY2ltYWxcIikge1xuICAgICAgICBoYXNEZWNpbWFsSW1wb3J0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ29UeXBlID09PSBcInV1aWQuVVVJRFwiKSB7XG4gICAgICAgIGhhc1VVSURJbXBvcnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBjYXBpdGFsaXplRmlyc3QobmFtZSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBvcHRpb25zLnVzZVBvaW50ZXIgJiYgZ29UeXBlICE9PSBcImludGVyZmFjZXt9XCIgPyBcIipcIiArIGdvVHlwZSA6IGdvVHlwZTtcbiAgICAgIGNvbnN0IHRhZ3MgPSBnZW5lcmF0ZVRhZ3MobmFtZSwgc3FsVHlwZSwgb3B0aW9ucyk7XG4gICAgICBzdHJ1Y3QgKz0gXCJcXHRcIiArIGZpZWxkTmFtZSArIFwiIFwiICsgZmllbGRUeXBlICsgXCIgYFwiICsgdGFncyArIFwiYFxcblwiO1xuICAgIH1cbiAgfVxuXG4gIHN0cnVjdCArPSBcIn1cXG5cIjtcblxuICAvLyDmt7vliqDlv4XopoHnmoTlr7zlhaVcbiAgY29uc3QgaW1wb3J0czogc3RyaW5nW10gPSBbXTtcbiAgaWYgKGhhc1RpbWVJbXBvcnQpIHtcbiAgICBpbXBvcnRzLnB1c2goJ3RpbWUnKTtcbiAgfVxuICBpZiAoaGFzRGVjaW1hbEltcG9ydCkge1xuICAgIGltcG9ydHMucHVzaCgnZ2l0aHViLmNvbS9zaG9wc3ByaW5nL2RlY2ltYWwnKTtcbiAgfVxuICBpZiAoaGFzVVVJREltcG9ydCkge1xuICAgIGltcG9ydHMucHVzaCgnZ2l0aHViLmNvbS9nb29nbGUvdXVpZCcpO1xuICB9XG5cbiAgaWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgIHN0cnVjdCA9ICdpbXBvcnQgKFxcblxcdFwiJyArIGltcG9ydHMuam9pbignXCJcXG5cXHRcIicpICsgJ1wiXFxuKVxcblxcbicgKyBzdHJ1Y3Q7XG4gIH1cblxuICByZXR1cm4gc3RydWN0O1xufVxuXG5leHBvcnQgY29uc3QgU1FMX1RFTVBMQVRFID0gYC0tIOeUqOaIt+ihqOekuuS+i1xuaWQgYmlnaW50XG51c2VybmFtZSB2YXJjaGFyKDI1NSlcbmVtYWlsIHZhcmNoYXIoMjU1KVxucGFzc3dvcmQgdmFyY2hhcigyNTUpXG5hZ2UgaW50XG5jcmVhdGVkX2F0IGRhdGV0aW1lXG51cGRhdGVkX2F0IHRpbWVzdGFtcFxuaXNfYWN0aXZlIGJvb2xlYW5cbnByb2ZpbGVfZGF0YSBqc29uXG5gO1xuXG4vLyDmt7vliqDmoLzlvI/moKHpqozlh73mlbBcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChpbnB1dDogc3RyaW5nLCB0eXBlOiAnanNvbicgfCAneWFtbCcgfCAnc3FsJyB8ICdwcm90bycgfCAneG1sJyB8ICdjc3YnKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgaWYgKCFpbnB1dC50cmltKCkpIHtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IFwi6L6T5YWl5YaF5a655Li656m6XCIgfTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICAgIGNhc2UgJ3lhbWwnOlxuICAgICAgICBZQU1MLnBhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgY2FzZSAnc3FsJzpcbiAgICAgICAgY29uc3Qgc3FsTGluZXMgPSBpbnB1dC5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICYmICFsaW5lLnN0YXJ0c1dpdGgoJy0tJykpO1xuICAgICAgICBpZiAoc3FsTGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIuayoeacieaJvuWIsOacieaViOeahCBTUUwg5a2X5q615a6a5LmJXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3FsTGluZXMpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUudHJpbSgpLm1hdGNoKC9eW2EtekEtWjAtOV9dK1xccytbYS16QS1aXSsoXFwoXFxkK1xcKSk/JC9pKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IGDml6DmlYjnmoQgU1FMIOWtl+auteWumuS5iTogJHtsaW5lfWAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgY2FzZSAncHJvdG8nOlxuICAgICAgICBpZiAoIWlucHV0LmluY2x1ZGVzKCdtZXNzYWdlJykpIHtcbiAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IFwi5pyq5om+5YiwIG1lc3NhZ2Ug5a6a5LmJXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gICAgICBjYXNlICd4bWwnOlxuICAgICAgICBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGlucHV0LCAndGV4dC94bWwnKTtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgY2FzZSAnY3N2JzpcbiAgICAgICAgY29uc3QgY3N2TGluZXMgPSBpbnB1dC5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgICAgICAgaWYgKGNzdkxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IFwiQ1NWIOiHs+WwkemcgOimgeWMheWQq+agh+mimOihjOWSjOS4gOihjOaVsOaNrlwiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIuS4jeaUr+aMgeeahOagvOW8j+exu+Wei1wiIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBg5qC85byP6ZSZ6K+vOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICfmnKrnn6XplJnor68nfWAgfTtcbiAgfVxufVxuXG4vLyDmt7vliqDnpLrkvovmqKHmnb9cbmV4cG9ydCBjb25zdCBURU1QTEFURVMgPSB7XG4gIGpzb246IGB7XG4gIFwiaWRcIjogMSxcbiAgXCJuYW1lXCI6IFwiZXhhbXBsZVwiLFxuICBcImFnZVwiOiAyNSxcbiAgXCJlbWFpbFwiOiBcInRlc3RAZXhhbXBsZS5jb21cIixcbiAgXCJpc19hY3RpdmVcIjogdHJ1ZSxcbiAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wMy0yMVQxMjowMDowMFpcIixcbiAgXCJ0YWdzXCI6IFtcInRhZzFcIiwgXCJ0YWcyXCJdLFxuICBcInByb2ZpbGVcIjoge1xuICAgIFwiYWRkcmVzc1wiOiBcIjEyMyBTdHJlZXRcIixcbiAgICBcInBob25lXCI6IFwiMTIzNDU2Nzg5MFwiXG4gIH1cbn1gLFxuICB5YW1sOiBgaWQ6IDFcbm5hbWU6IGV4YW1wbGVcbmFnZTogMjVcbmVtYWlsOiB0ZXN0QGV4YW1wbGUuY29tXG5pc19hY3RpdmU6IHRydWVcbmNyZWF0ZWRfYXQ6IDIwMjQtMDMtMjFUMTI6MDA6MDBaXG50YWdzOlxuICAtIHRhZzFcbiAgLSB0YWcyXG5wcm9maWxlOlxuICBhZGRyZXNzOiAxMjMgU3RyZWV0XG4gIHBob25lOiBcIjEyMzQ1Njc4OTBcImAsXG4gIHNxbDogU1FMX1RFTVBMQVRFLFxuICBwcm90bzogYHN5bnRheCA9IFwicHJvdG8zXCI7XG5cbnBhY2thZ2UgZXhhbXBsZTtcblxubWVzc2FnZSBVc2VyIHtcbiAgaW50NjQgaWQgPSAxO1xuICBzdHJpbmcgbmFtZSA9IDI7XG4gIGludDMyIGFnZSA9IDM7XG4gIHN0cmluZyBlbWFpbCA9IDQ7XG4gIGJvb2wgaXNfYWN0aXZlID0gNTtcbiAgc3RyaW5nIGNyZWF0ZWRfYXQgPSA2O1xuICByZXBlYXRlZCBzdHJpbmcgdGFncyA9IDc7XG4gIFByb2ZpbGUgcHJvZmlsZSA9IDg7XG59XG5cbm1lc3NhZ2UgUHJvZmlsZSB7XG4gIHN0cmluZyBhZGRyZXNzID0gMTtcbiAgc3RyaW5nIHBob25lID0gMjtcbn1gLFxuICB4bWw6IGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cbjx1c2VyPlxuICA8aWQ+MTwvaWQ+XG4gIDxuYW1lPmV4YW1wbGU8L25hbWU+XG4gIDxhZ2U+MjU8L2FnZT5cbiAgPGVtYWlsPnRlc3RAZXhhbXBsZS5jb208L2VtYWlsPlxuICA8aXNfYWN0aXZlPnRydWU8L2lzX2FjdGl2ZT5cbiAgPGNyZWF0ZWRfYXQ+MjAyNC0wMy0yMVQxMjowMDowMFo8L2NyZWF0ZWRfYXQ+XG4gIDx0YWdzPlxuICAgIDx0YWc+dGFnMTwvdGFnPlxuICAgIDx0YWc+dGFnMjwvdGFnPlxuICA8L3RhZ3M+XG4gIDxwcm9maWxlPlxuICAgIDxhZGRyZXNzPjEyMyBTdHJlZXQ8L2FkZHJlc3M+XG4gICAgPHBob25lPjEyMzQ1Njc4OTA8L3Bob25lPlxuICA8L3Byb2ZpbGU+XG48L3VzZXI+YCxcbiAgY3N2OiBgaWQsbmFtZSxhZ2UsZW1haWwsaXNfYWN0aXZlLGNyZWF0ZWRfYXRcbjEsZXhhbXBsZSwyNSx0ZXN0QGV4YW1wbGUuY29tLHRydWUsMjAyNC0wMy0yMVQxMjowMDowMFpgXG59O1xuXG4vLyBQcm90byDovawgR28g57uT5p6E5L2TXG5mdW5jdGlvbiBwcm90b1RvR28ocHJvdG86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmVzID0gcHJvdG8uc3BsaXQoL1xccj9cXG4vKTtcbiAgbGV0IG91dHB1dCA9IFwiXCI7XG4gIGxldCBjdXJyZW50TWVzc2FnZSA9IFwiXCI7XG4gIGxldCBpbXBvcnRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgLy8g5b+955Wl56m66KGM5ZKMIHByb3RvIOivreazleWjsOaYjlxuICAgIGlmICghbGluZS50cmltKCkgfHwgbGluZS5pbmNsdWRlcygnc3ludGF4JykgfHwgbGluZS5pbmNsdWRlcygncGFja2FnZScpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyDlpITnkIbmtojmga/lrprkuYlcbiAgICBpZiAobGluZS5pbmNsdWRlcygnbWVzc2FnZScpKSB7XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgb3V0cHV0ICs9IFwifVxcblxcblwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZU5hbWUgPSBsaW5lLm1hdGNoKC9tZXNzYWdlXFxzKyhcXHcrKS8pPy5bMV07XG4gICAgICBpZiAobWVzc2FnZU5hbWUpIHtcbiAgICAgICAgY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlTmFtZTtcbiAgICAgICAgb3V0cHV0ICs9IGB0eXBlICR7bWVzc2FnZU5hbWV9IHN0cnVjdCB7XFxuYDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIOWkhOeQhuWtl+autVxuICAgIGlmIChjdXJyZW50TWVzc2FnZSAmJiBsaW5lLnRyaW0oKSkge1xuICAgICAgY29uc3QgZmllbGRNYXRjaCA9IGxpbmUubWF0Y2goL1xccyoocmVwZWF0ZWQpP1xccyooXFx3KylcXHMrKFxcdyspXFxzKj1cXHMqXFxkKzsvKTtcbiAgICAgIGlmIChmaWVsZE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIHJlcGVhdGVkLCB0eXBlLCBuYW1lXSA9IGZpZWxkTWF0Y2g7XG4gICAgICAgIGNvbnN0IGdvVHlwZSA9IHByb3RvVHlwZVRvR28odHlwZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGNhcGl0YWxpemVGaXJzdChuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcmVwZWF0ZWQgPyBgW10ke2dvVHlwZX1gIDogZ29UeXBlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGdvVHlwZSA9PT0gXCJ0aW1lLlRpbWVcIikge1xuICAgICAgICAgIGltcG9ydHMuYWRkKCd0aW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgKz0gYFxcdCR7ZmllbGROYW1lfSAke2ZpZWxkVHlwZX0gXFxganNvbjpcIiR7bmFtZX1cIlxcYFxcbmA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnRNZXNzYWdlKSB7XG4gICAgb3V0cHV0ICs9IFwifVxcblwiO1xuICB9XG5cbiAgaWYgKGltcG9ydHMuc2l6ZSA+IDApIHtcbiAgICBvdXRwdXQgPSAnaW1wb3J0IChcXG5cXHRcIicgKyBBcnJheS5mcm9tKGltcG9ydHMpLmpvaW4oJ1wiXFxuXFx0XCInKSArICdcIlxcbilcXG5cXG4nICsgb3V0cHV0O1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gUHJvdG8g57G75Z6L6L2sIEdvIOexu+Wei1xuZnVuY3Rpb24gcHJvdG9UeXBlVG9Hbyh0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICdkb3VibGUnOiAnZmxvYXQ2NCcsXG4gICAgJ2Zsb2F0JzogJ2Zsb2F0MzInLFxuICAgICdpbnQzMic6ICdpbnQzMicsXG4gICAgJ2ludDY0JzogJ2ludDY0JyxcbiAgICAndWludDMyJzogJ3VpbnQzMicsXG4gICAgJ3VpbnQ2NCc6ICd1aW50NjQnLFxuICAgICdzaW50MzInOiAnaW50MzInLFxuICAgICdzaW50NjQnOiAnaW50NjQnLFxuICAgICdmaXhlZDMyJzogJ3VpbnQzMicsXG4gICAgJ2ZpeGVkNjQnOiAndWludDY0JyxcbiAgICAnc2ZpeGVkMzInOiAnaW50MzInLFxuICAgICdzZml4ZWQ2NCc6ICdpbnQ2NCcsXG4gICAgJ2Jvb2wnOiAnYm9vbCcsXG4gICAgJ3N0cmluZyc6ICdzdHJpbmcnLFxuICAgICdieXRlcyc6ICdbXWJ5dGUnLFxuICAgICdUaW1lc3RhbXAnOiAndGltZS5UaW1lJ1xuICB9O1xuICByZXR1cm4gdHlwZU1hcFt0eXBlXSB8fCB0eXBlO1xufVxuXG4vLyBYTUwg6L2sIEdvIOe7k+aehOS9k1xuZnVuY3Rpb24geG1sVG9Hbyh4bWw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIGNvbnN0IGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKTtcbiAgICBjb25zdCByb290ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBcbiAgICByZXR1cm4gcHJvY2Vzc1hNTE5vZGUocm9vdCwgY2FwaXRhbGl6ZUZpcnN0KHJvb3QudGFnTmFtZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdYTUwg6Kej5p6Q6ZSZ6K+vJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1hNTE5vZGUobm9kZTogRWxlbWVudCwgc3RydWN0TmFtZTogc3RyaW5nLCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCkpOiBzdHJpbmcge1xuICBpZiAoc2Vlbi5oYXMoc3RydWN0TmFtZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgc2Vlbi5hZGQoc3RydWN0TmFtZSk7XG5cbiAgbGV0IHN0cnVjdCA9IGB0eXBlICR7c3RydWN0TmFtZX0gc3RydWN0IHtcXG5gO1xuICBjb25zdCBuZXN0ZWRTdHJ1Y3RzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBmaWVsZHMgPSBuZXcgTWFwPHN0cmluZywgeyB0eXBlOiBzdHJpbmc7IGlzQXJyYXk6IGJvb2xlYW4gfT4oKTtcblxuICAvLyDlpITnkIblrZDlhYPntKBcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBBcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gY2FwaXRhbGl6ZUZpcnN0KGNoaWxkLnRhZ05hbWUpO1xuICAgIGNvbnN0IGV4aXN0aW5nRmllbGQgPSBmaWVsZHMuZ2V0KGZpZWxkTmFtZSk7XG5cbiAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IChjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGQuY2hpbGRyZW5bMF0ubm9kZVR5cGUgPT09IDMpKSB7XG4gICAgICAvLyDnroDljZXlgLxcbiAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcbiAgICAgIGNvbnN0IHR5cGUgPSBpbmZlclR5cGVGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgXG4gICAgICBpZiAoZXhpc3RpbmdGaWVsZCkge1xuICAgICAgICBleGlzdGluZ0ZpZWxkLmlzQXJyYXkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzLnNldChmaWVsZE5hbWUsIHsgdHlwZSwgaXNBcnJheTogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOWkjeadguexu+Wei1xuICAgICAgY29uc3QgbmVzdGVkU3RydWN0TmFtZSA9IHN0cnVjdE5hbWUgKyBmaWVsZE5hbWU7XG4gICAgICBuZXN0ZWRTdHJ1Y3RzLnB1c2gocHJvY2Vzc1hNTE5vZGUoY2hpbGQsIG5lc3RlZFN0cnVjdE5hbWUsIHNlZW4pKTtcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nRmllbGQpIHtcbiAgICAgICAgZXhpc3RpbmdGaWVsZC5pc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkcy5zZXQoZmllbGROYW1lLCB7IHR5cGU6IG5lc3RlZFN0cnVjdE5hbWUsIGlzQXJyYXk6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIOeUn+aIkOWtl+autVxuICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHsgdHlwZSwgaXNBcnJheSB9XSBvZiBmaWVsZHMpIHtcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBpc0FycmF5ID8gYFtdJHt0eXBlfWAgOiB0eXBlO1xuICAgIHN0cnVjdCArPSBgXFx0JHtmaWVsZE5hbWV9ICR7ZmllbGRUeXBlfSBcXGB4bWw6XCIke2ZpZWxkTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGpzb246XCIke2ZpZWxkTmFtZS50b0xvd2VyQ2FzZSgpfVwiXFxgXFxuYDtcbiAgfVxuXG4gIHN0cnVjdCArPSBcIn1cXG5cXG5cIjtcbiAgcmV0dXJuIG5lc3RlZFN0cnVjdHMuam9pbignJykgKyBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIGluZmVyVHlwZUZyb21WYWx1ZSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHJldHVybiAnYm9vbCc7XG4gIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkgcmV0dXJuICdpbnQnO1xuICBpZiAoL15cXGQqXFwuXFxkKyQvLnRlc3QodmFsdWUpKSByZXR1cm4gJ2Zsb2F0NjQnO1xuICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfS8udGVzdCh2YWx1ZSkpIHJldHVybiAndGltZS5UaW1lJztcbiAgcmV0dXJuICdzdHJpbmcnO1xufVxuXG4vLyBDU1Yg6L2sIEdvIOe7k+aehOS9k1xuZnVuY3Rpb24gY3N2VG9Hbyhjc3Y6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmVzID0gY3N2LnNwbGl0KC9cXHI/XFxuLykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ1NWIOiHs+WwkemcgOimgeWMheWQq+agh+mimOihjOWSjOS4gOihjOaVsOaNricpO1xuICB9XG5cbiAgY29uc3QgaGVhZGVycyA9IGxpbmVzWzBdLnNwbGl0KCcsJykubWFwKGggPT4gaC50cmltKCkpO1xuICBjb25zdCBmaXJzdFJvdyA9IGxpbmVzWzFdLnNwbGl0KCcsJykubWFwKHYgPT4gdi50cmltKCkpO1xuICBcbiAgbGV0IHN0cnVjdCA9IFwidHlwZSBBdXRvR2VuIHN0cnVjdCB7XFxuXCI7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmaWVsZE5hbWUgPSBjYXBpdGFsaXplRmlyc3QoaGVhZGVyc1tpXSk7XG4gICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvd1tpXTtcbiAgICBjb25zdCB0eXBlID0gaW5mZXJUeXBlRnJvbVZhbHVlKHZhbHVlKTtcbiAgICBzdHJ1Y3QgKz0gYFxcdCR7ZmllbGROYW1lfSAke3R5cGV9IFxcYGpzb246XCIke2hlYWRlcnNbaV19XCJcXGBcXG5gO1xuICB9XG4gIFxuICBzdHJ1Y3QgKz0gXCJ9XFxuXCI7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbi8vIOWvvOWHuuaWsOeahOi9rOaNouWHveaVsFxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0dvKGlucHV0OiBzdHJpbmcsIHR5cGU6ICdqc29uJyB8ICd5YW1sJyB8ICdzcWwnIHwgJ3Byb3RvJyB8ICd4bWwnIHwgJ2NzdicsIG9wdGlvbnM/OiBTUUxPcHRpb25zKTogc3RyaW5nIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnanNvbic6XG4gICAgICByZXR1cm4ganNvblRvR28oSlNPTi5wYXJzZShpbnB1dCksICdBdXRvR2VuJyk7XG4gICAgY2FzZSAneWFtbCc6XG4gICAgICByZXR1cm4ganNvblRvR28oWUFNTC5wYXJzZShpbnB1dCksICdBdXRvR2VuJyk7XG4gICAgY2FzZSAnc3FsJzpcbiAgICAgIHJldHVybiBzcWxUb0dvU3RydWN0KGlucHV0LCBvcHRpb25zISk7XG4gICAgY2FzZSAncHJvdG8nOlxuICAgICAgcmV0dXJuIHByb3RvVG9HbyhpbnB1dCk7XG4gICAgY2FzZSAneG1sJzpcbiAgICAgIHJldHVybiB4bWxUb0dvKGlucHV0KTtcbiAgICBjYXNlICdjc3YnOlxuICAgICAgcmV0dXJuIGNzdlRvR28oaW5wdXQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ+S4jeaUr+aMgeeahOagvOW8j+exu+WeiycpO1xuICB9XG59ICJdLCJuYW1lcyI6WyJZQU1MIiwiaW5mZXJHb1R5cGUiLCJ2YWx1ZSIsInNlZW4iLCJTZXQiLCJ1bmRlZmluZWQiLCJ0eXBlIiwiaXNQb2ludGVyIiwiaXNBcnJheSIsIkFycmF5IiwibGVuZ3RoIiwiZWxlbWVudFR5cGVzIiwibWFwIiwiaXRlbSIsImlzU2FtZVR5cGUiLCJldmVyeSIsInQiLCJlbGVtZW50VHlwZSIsIk51bWJlciIsImlzSW50ZWdlciIsImhhcyIsImFkZCIsImZvcm1hdEdvRmllbGRUeXBlIiwicmVzdWx0IiwiY2FwaXRhbGl6ZUZpcnN0Iiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImpzb25Ub0dvIiwib2JqIiwic3RydWN0TmFtZSIsIm5lc3RlZFN0cnVjdHMiLCJzdHJ1Y3QiLCJrZXkiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmllbGROYW1lIiwiZ29UeXBlIiwibmVzdGVkU3RydWN0TmFtZSIsImVsZW1lbnRWYWx1ZSIsInB1c2giLCJqb2luIiwiZm9ybWF0SlNPTiIsImlucHV0IiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZm9ybWF0WUFNTCIsImluZGVudCIsInNxbFR5cGVNYXAiLCJteXNxbCIsInBvc3RncmVzIiwic3FsaXRlIiwib3JhY2xlIiwiZ2VuZXJhdGVUYWdzIiwibmFtZSIsInNxbFR5cGUiLCJvcHRpb25zIiwidGFncyIsInRhZ1R5cGUiLCJnb3JtVGFncyIsInhvcm1UYWdzIiwic3FsVG9Hb1N0cnVjdCIsInNxbCIsImxpbmVzIiwic3BsaXQiLCJoYXNUaW1lSW1wb3J0IiwiaGFzRGVjaW1hbEltcG9ydCIsImhhc1VVSURJbXBvcnQiLCJsaW5lIiwibWF0Y2giLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJkYlR5cGUiLCJmaWVsZFR5cGUiLCJ1c2VQb2ludGVyIiwiaW1wb3J0cyIsIlNRTF9URU1QTEFURSIsInZhbGlkYXRlRm9ybWF0IiwiaXNWYWxpZCIsImVycm9yIiwic3FsTGluZXMiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJjc3ZMaW5lcyIsImUiLCJFcnJvciIsIm1lc3NhZ2UiLCJURU1QTEFURVMiLCJqc29uIiwieWFtbCIsInByb3RvIiwieG1sIiwiY3N2IiwicHJvdG9Ub0dvIiwib3V0cHV0IiwiY3VycmVudE1lc3NhZ2UiLCJtZXNzYWdlTmFtZSIsImZpZWxkTWF0Y2giLCJyZXBlYXRlZCIsInByb3RvVHlwZVRvR28iLCJzaXplIiwiZnJvbSIsInR5cGVNYXAiLCJ4bWxUb0dvIiwicGFyc2VyIiwiZG9jIiwicm9vdCIsImRvY3VtZW50RWxlbWVudCIsInByb2Nlc3NYTUxOb2RlIiwidGFnTmFtZSIsIm5vZGUiLCJmaWVsZHMiLCJNYXAiLCJjaGlsZCIsImNoaWxkcmVuIiwiZXhpc3RpbmdGaWVsZCIsImdldCIsIm5vZGVUeXBlIiwidGV4dENvbnRlbnQiLCJpbmZlclR5cGVGcm9tVmFsdWUiLCJzZXQiLCJ0ZXN0IiwiY3N2VG9HbyIsImhlYWRlcnMiLCJoIiwiZmlyc3RSb3ciLCJ2IiwiaSIsImNvbnZlcnRUb0dvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/utils.ts\n"));

/***/ })

});